<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>satcamsim.save_output API documentation</title>
<meta name="description" content="Provides output and temp file handling utilities." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>satcamsim.save_output</code></h1>
</header>
<section id="section-intro">
<p>Provides output and temp file handling utilities.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Provides output and temp file handling utilities.&#34;&#34;&#34;

import os
from shutil import rmtree
from uuid import uuid4
import pickle
import time
from PIL import Image
from csv import writer


class FolderExistsError(FileExistsError):
    &#34;&#34;&#34;Raised if attempting to create a directory which already exists.&#34;&#34;&#34;


class Temp_handler:
    &#34;&#34;&#34;Handles saving, loading, and deletion of temp files. Ensures deletion of all files when exiting.&#34;&#34;&#34;

    def __init__(self):
        self.files = []
        return

    def from_config(config):
        &#34;&#34;&#34;
        Initialize Temp_handler with config parameters.

        Parameters
        ----------
        config : Config
            Config instance containing desired parameters.

        Returns
        -------
        handler : Temp_handler
            initialized according to config parameters.

        &#34;&#34;&#34;
        handler = Temp_handler()
        handler.parent_folder = config[&#39;OUTPUT_FOLDER&#39;]
        return handler

    def __enter__(self):
        &#34;&#34;&#34;
        Create temp directories.

        Raises
        ------
        FolderExistsError
            if a directory with the same name already exists.

        Returns
        -------
        self : Temp_handler

        &#34;&#34;&#34;
        super_temp_folder = self.parent_folder + &#39;temp\\&#39;
        if not os.path.isdir(super_temp_folder):
            os.mkdir(super_temp_folder)

        temp_ident = str(uuid4())
        self.temp_folder = self.parent_folder + &#39;temp\\&#39; + temp_ident + &#39;\\&#39;

        try:
            os.mkdir(self.temp_folder)
        except FileExistsError:
            raise FolderExistsError(&#39;folder already exists: &#39; + self.temp_folder)

        return self

    def __exit__(self, exc_type, exc_value, traceback):
        &#34;&#34;&#34;
        Ensure deletion of all temp files when exiting context manager.

        Parameters
        ----------
        exc_type : exception type or None
            Type of exception raised within context manager, or None.
        exc_value : Exception or None
            The exception raised within context manager, or None.
        traceback : Traceback or None
            Traceback object for the raised exception, or None.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        if exc_type == FolderExistsError:
            return

        if os.path.isdir(self.temp_folder):
            rmtree(self.temp_folder)
        return

    def save(self, obj):
        &#34;&#34;&#34;
        Save an object to a temp file.

        Parameters
        ----------
        obj : object
            The object to be stored. Must be pickleable.

        Returns
        -------
        ident : str
            unique identifier to retrieve the object from memory.

        &#34;&#34;&#34;
        ident = str(uuid4())
        if os.path.exists(self.temp_folder + ident):
            raise FileExistsError(&#39;file already exists: &#39; + self.temp_folder + ident)
        with open(self.temp_folder + ident, &#39;wb&#39;) as pfile:
            pickle.dump(obj, pfile)
        self.files.append(ident)
        return ident

    def load(self, ident):
        &#34;&#34;&#34;
        Load an object stored in a temp file from memory.

        Parameters
        ----------
        ident : str
            the object&#39;s unique identifier returned when storing it.

        Returns
        -------
        obj : object
            the stored object.

        &#34;&#34;&#34;
        with open(self.temp_folder + ident, &#39;rb&#39;) as pfile:
            return pickle.load(pfile)

    def load_all(self):
        &#34;&#34;&#34;
        Load all objects stored in temp files by this Temp_handler.

        Returns
        -------
        objs: list
            contains all loaded objects in the order they were stored in.

        &#34;&#34;&#34;
        return [self.load(ident) for ident in self.files]

    def remove(self, ident):
        &#34;&#34;&#34;
        Delete a stored object from memory.

        Parameters
        ----------
        ident : str
            the object&#39;s unique identifier returned when storing it.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        os.remove(self.temp_folder + ident)
        self.files.remove(ident)
        return


class Output_saver:
    &#34;&#34;&#34;Provides output handling utilities.&#34;&#34;&#34;

    def from_config(config):
        &#34;&#34;&#34;
        Initialize Output_saver with config parameters.

        Parameters
        ----------
        config : Config
            Config instance containing desired parameters.

        Returns
        -------
        saver : Output_saver
            initialized according to config parameters.

        &#34;&#34;&#34;
        saver = Output_saver()
        saver.parent_folder = config[&#39;OUTPUT_FOLDER&#39;]
        saver.setup()
        return saver

    def setup(self):
        &#34;&#34;&#34;
        Create required files and directories.

        Raises
        ------
        FolderExistsError
            Raised if directory already exists..

        Returns
        -------
        None.

        &#34;&#34;&#34;
        ident = time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;_output\\&#39;
        self.out_folder = self.parent_folder + ident
        try:
            os.mkdir(self.out_folder)
        except FileExistsError:
            raise FolderExistsError(&#39;folder already exists: &#39; + self.out_folder + str(self.file_counter) + &#39;\\&#39;)

        self.logfile = self.out_folder + &#39;log.txt&#39;
        with open(self.logfile, &#39;w&#39;) as log:
            log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: directory and log file created\n&#39;)

        self.file_counter = 1
        return

    def __enter__(self):
        &#34;&#34;&#34;
        Open Output_saver context and write message to log file.

        Returns
        -------
        self : Output_saver

        &#34;&#34;&#34;
        with open(self.logfile, &#39;a&#39;) as log:
            log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: entering output saver\n&#39;)
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        &#34;&#34;&#34;
        Write message to log file and leave Output_saver context.

        Parameters
        ----------
        exc_type : exception type or None
            Type of exception raised within context manager, or None.
        exc_value : Exception or None
            The exception raised within context manager, or None.
        traceback : Traceback or None
            Traceback object for the raised exception, or None.

        Returns
        -------
        None.
        &#34;&#34;&#34;
        with open(self.logfile, &#39;a&#39;) as log:
            log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: exiting output saver\n&#39;)
        return

    def save_imgs(self, imgs):
        &#34;&#34;&#34;
        Save an iterable containing images.

        Parameters
        ----------
        imgs : iterable
            Iterable containing the images to be saved.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        for img in imgs:
            self.save_img(img)
        return

    def save_img(self, img, subfolder=&#39;&#39;, filename=None):
        &#34;&#34;&#34;
        Save one or multiple images, single or multi-channel, contained within a single array.
        Detailed behavior:
            - if img.ndim &lt; 2: a warning is raised and img is pickled instead of saved as an image
            - if img.ndim == 2: img saved as single-channel image
            - if img.ndim == 3:
                - if img.shape[0] == 1: img saved as single-channel image
                - if img.shape[0] in (3, 4): img saved as RGB/RGBA image
                - else: individual channels are saved as single-channel images in a subdirectory
            - else: img[i] is passed into this function recursively, thus reducing img.ndim by one.
        Log message is recorded accordingly.

        Parameters
        ----------
        img : np.ndarray
            the array containing one or multiple images.
        subfolder : str, optional
            name of the subdirectory the image will bestored in, if . The default is &#39;&#39;.
        filename : str, optional
            file name of the stored image. Works only if img can be saved in a single file.
            If not provided, a number will be assigned as file name.

        Raises
        ------
        FolderExistsError
            if a subdirectory with the same name already exists.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        if img.ndim &lt; 2:
            filename = &#39;failed_img_&#39; + str(self.file_counter)
            self.save(img, filename=filename)
            raise Warning(&#39;img must have img.ndim&gt;=2, was instead pickled as &#39; + filename)
            with open(self.logfile, &#39;a&#39;) as log:
                log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: array with ndim &lt; 2  could not be stored as image, pickled instead: &#39; + filename + &#39;\n&#39;)

        elif img.ndim == 2:
            self.save_img(img[None, :, :])

        elif img.ndim == 3:
            if img.shape[0] in (1, 3, 4):
                if not filename:
                    filename = str(self.file_counter) + &#34;.tif&#34;
                with open(self.logfile, &#39;a&#39;) as log:
                    log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: start saving &#39; + subfolder + filename + &#39;\n&#39;)
                im = Image.fromarray(img.swapaxes(0, 2).swapaxes(0, 1))
                im.save(self.out_folder + subfolder + filename)
                self.file_counter += 1
                with open(self.logfile, &#39;a&#39;) as log:
                    log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: finished saving &#39; + subfolder + filename + &#39;\n&#39;)
            else:
                with open(self.logfile, &#39;a&#39;) as log:
                    log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: array with no. of channels other than 1, 3, or 4 will be stored as individual images\n&#39;)
                try:
                    os.mkdir(self.out_folder + str(self.file_counter) + &#39;\\&#39;)
                except FileExistsError:
                    raise FolderExistsError(&#39;folder already exists: &#39; + self.out_folder + str(self.file_counter) + &#39;\\&#39;)
                [self.save_img(img[None, i, :, :], subfolder=str(self.file_counter) + &#39;\\&#39;, filename=str(i)) for i in range(img.shape[0])]

        else:
            with open(self.logfile, &#39;a&#39;) as log:
                log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: array ndim &gt; 3 will be stored as individual images\n&#39;)
            for i in range(img.shape[0]):
                self.save_img(img[i, :, :, :])
        return

    def save_config(self, config):
        &#34;&#34;&#34;
        Save current config parameters in the log file. Parameters are read from the values in camera and input_imgs modules.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        with open(self.logfile, &#39;a&#39;) as log:
            log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: start saving config parameters\n&#39;)
            log.write(str(config) + &#39;\n&#39;)
            log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: finished saving config parameters\n&#39;)
        return

    def save_csv(self, iterables, header=None, filename=None):
        &#34;&#34;&#34;
        Save an iterable of iterables as a csv file.

        Parameters
        ----------
        iterables : Iterable[Iterable]
            an Iterable containing the rows to be written to file.
        header : Iterable, optional
            an Iterable optionally specifying column headers. Must have len(header) == len(iterables).
        filename : str, optional
            name of the produced file. If not provided, a number will be assigned as file name.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        if not filename:
            filename = str(self.file_counter)
        self.file_counter += 1

        with open(self.out_folder + filename, &#39;w&#39;, newline=&#39;&#39;) as file:
            csv_writer = writer(file)

            if header:
                csv_writer.writerow(header)

            csv_writer.writerows(iterables)
        return

    def save(self, obj, filename=None):
        &#34;&#34;&#34;
        Save arbitrary objects.

        Parameters
        ----------
        obj : object
            The object to be stored. Must be pickleable.
        filename : str, optional
            file name of the stored object. If not provided, a number will be assigned as file name.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        if not filename:
            filename = str(self.file_counter)
        self.file_counter += 1

        with open(self.logfile, &#39;a&#39;) as log:
            log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: start saving &#39; + filename + &#39;\n&#39;)
        with open(self.out_folder + filename, &#39;wb&#39;) as pfile:
            pickle.dump(obj, pfile)
        with open(self.logfile, &#39;a&#39;) as log:
            log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: finished saving &#39; + filename + &#39;\n&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="satcamsim.save_output.FolderExistsError"><code class="flex name class">
<span>class <span class="ident">FolderExistsError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Raised if attempting to create a directory which already exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FolderExistsError(FileExistsError):
    &#34;&#34;&#34;Raised if attempting to create a directory which already exists.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.FileExistsError</li>
<li>builtins.OSError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="satcamsim.save_output.Output_saver"><code class="flex name class">
<span>class <span class="ident">Output_saver</span></span>
</code></dt>
<dd>
<div class="desc"><p>Provides output handling utilities.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Output_saver:
    &#34;&#34;&#34;Provides output handling utilities.&#34;&#34;&#34;

    def from_config(config):
        &#34;&#34;&#34;
        Initialize Output_saver with config parameters.

        Parameters
        ----------
        config : Config
            Config instance containing desired parameters.

        Returns
        -------
        saver : Output_saver
            initialized according to config parameters.

        &#34;&#34;&#34;
        saver = Output_saver()
        saver.parent_folder = config[&#39;OUTPUT_FOLDER&#39;]
        saver.setup()
        return saver

    def setup(self):
        &#34;&#34;&#34;
        Create required files and directories.

        Raises
        ------
        FolderExistsError
            Raised if directory already exists..

        Returns
        -------
        None.

        &#34;&#34;&#34;
        ident = time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;_output\\&#39;
        self.out_folder = self.parent_folder + ident
        try:
            os.mkdir(self.out_folder)
        except FileExistsError:
            raise FolderExistsError(&#39;folder already exists: &#39; + self.out_folder + str(self.file_counter) + &#39;\\&#39;)

        self.logfile = self.out_folder + &#39;log.txt&#39;
        with open(self.logfile, &#39;w&#39;) as log:
            log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: directory and log file created\n&#39;)

        self.file_counter = 1
        return

    def __enter__(self):
        &#34;&#34;&#34;
        Open Output_saver context and write message to log file.

        Returns
        -------
        self : Output_saver

        &#34;&#34;&#34;
        with open(self.logfile, &#39;a&#39;) as log:
            log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: entering output saver\n&#39;)
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        &#34;&#34;&#34;
        Write message to log file and leave Output_saver context.

        Parameters
        ----------
        exc_type : exception type or None
            Type of exception raised within context manager, or None.
        exc_value : Exception or None
            The exception raised within context manager, or None.
        traceback : Traceback or None
            Traceback object for the raised exception, or None.

        Returns
        -------
        None.
        &#34;&#34;&#34;
        with open(self.logfile, &#39;a&#39;) as log:
            log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: exiting output saver\n&#39;)
        return

    def save_imgs(self, imgs):
        &#34;&#34;&#34;
        Save an iterable containing images.

        Parameters
        ----------
        imgs : iterable
            Iterable containing the images to be saved.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        for img in imgs:
            self.save_img(img)
        return

    def save_img(self, img, subfolder=&#39;&#39;, filename=None):
        &#34;&#34;&#34;
        Save one or multiple images, single or multi-channel, contained within a single array.
        Detailed behavior:
            - if img.ndim &lt; 2: a warning is raised and img is pickled instead of saved as an image
            - if img.ndim == 2: img saved as single-channel image
            - if img.ndim == 3:
                - if img.shape[0] == 1: img saved as single-channel image
                - if img.shape[0] in (3, 4): img saved as RGB/RGBA image
                - else: individual channels are saved as single-channel images in a subdirectory
            - else: img[i] is passed into this function recursively, thus reducing img.ndim by one.
        Log message is recorded accordingly.

        Parameters
        ----------
        img : np.ndarray
            the array containing one or multiple images.
        subfolder : str, optional
            name of the subdirectory the image will bestored in, if . The default is &#39;&#39;.
        filename : str, optional
            file name of the stored image. Works only if img can be saved in a single file.
            If not provided, a number will be assigned as file name.

        Raises
        ------
        FolderExistsError
            if a subdirectory with the same name already exists.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        if img.ndim &lt; 2:
            filename = &#39;failed_img_&#39; + str(self.file_counter)
            self.save(img, filename=filename)
            raise Warning(&#39;img must have img.ndim&gt;=2, was instead pickled as &#39; + filename)
            with open(self.logfile, &#39;a&#39;) as log:
                log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: array with ndim &lt; 2  could not be stored as image, pickled instead: &#39; + filename + &#39;\n&#39;)

        elif img.ndim == 2:
            self.save_img(img[None, :, :])

        elif img.ndim == 3:
            if img.shape[0] in (1, 3, 4):
                if not filename:
                    filename = str(self.file_counter) + &#34;.tif&#34;
                with open(self.logfile, &#39;a&#39;) as log:
                    log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: start saving &#39; + subfolder + filename + &#39;\n&#39;)
                im = Image.fromarray(img.swapaxes(0, 2).swapaxes(0, 1))
                im.save(self.out_folder + subfolder + filename)
                self.file_counter += 1
                with open(self.logfile, &#39;a&#39;) as log:
                    log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: finished saving &#39; + subfolder + filename + &#39;\n&#39;)
            else:
                with open(self.logfile, &#39;a&#39;) as log:
                    log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: array with no. of channels other than 1, 3, or 4 will be stored as individual images\n&#39;)
                try:
                    os.mkdir(self.out_folder + str(self.file_counter) + &#39;\\&#39;)
                except FileExistsError:
                    raise FolderExistsError(&#39;folder already exists: &#39; + self.out_folder + str(self.file_counter) + &#39;\\&#39;)
                [self.save_img(img[None, i, :, :], subfolder=str(self.file_counter) + &#39;\\&#39;, filename=str(i)) for i in range(img.shape[0])]

        else:
            with open(self.logfile, &#39;a&#39;) as log:
                log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: array ndim &gt; 3 will be stored as individual images\n&#39;)
            for i in range(img.shape[0]):
                self.save_img(img[i, :, :, :])
        return

    def save_config(self, config):
        &#34;&#34;&#34;
        Save current config parameters in the log file. Parameters are read from the values in camera and input_imgs modules.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        with open(self.logfile, &#39;a&#39;) as log:
            log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: start saving config parameters\n&#39;)
            log.write(str(config) + &#39;\n&#39;)
            log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: finished saving config parameters\n&#39;)
        return

    def save_csv(self, iterables, header=None, filename=None):
        &#34;&#34;&#34;
        Save an iterable of iterables as a csv file.

        Parameters
        ----------
        iterables : Iterable[Iterable]
            an Iterable containing the rows to be written to file.
        header : Iterable, optional
            an Iterable optionally specifying column headers. Must have len(header) == len(iterables).
        filename : str, optional
            name of the produced file. If not provided, a number will be assigned as file name.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        if not filename:
            filename = str(self.file_counter)
        self.file_counter += 1

        with open(self.out_folder + filename, &#39;w&#39;, newline=&#39;&#39;) as file:
            csv_writer = writer(file)

            if header:
                csv_writer.writerow(header)

            csv_writer.writerows(iterables)
        return

    def save(self, obj, filename=None):
        &#34;&#34;&#34;
        Save arbitrary objects.

        Parameters
        ----------
        obj : object
            The object to be stored. Must be pickleable.
        filename : str, optional
            file name of the stored object. If not provided, a number will be assigned as file name.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        if not filename:
            filename = str(self.file_counter)
        self.file_counter += 1

        with open(self.logfile, &#39;a&#39;) as log:
            log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: start saving &#39; + filename + &#39;\n&#39;)
        with open(self.out_folder + filename, &#39;wb&#39;) as pfile:
            pickle.dump(obj, pfile)
        with open(self.logfile, &#39;a&#39;) as log:
            log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: finished saving &#39; + filename + &#39;\n&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="satcamsim.save_output.Output_saver.from_config"><code class="name flex">
<span>def <span class="ident">from_config</span></span>(<span>config)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize Output_saver with config parameters.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>Config</code></dt>
<dd>Config instance containing desired parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>saver</code></strong> :&ensp;<code><a title="satcamsim.save_output.Output_saver" href="#satcamsim.save_output.Output_saver">Output_saver</a></code></dt>
<dd>initialized according to config parameters.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_config(config):
    &#34;&#34;&#34;
    Initialize Output_saver with config parameters.

    Parameters
    ----------
    config : Config
        Config instance containing desired parameters.

    Returns
    -------
    saver : Output_saver
        initialized according to config parameters.

    &#34;&#34;&#34;
    saver = Output_saver()
    saver.parent_folder = config[&#39;OUTPUT_FOLDER&#39;]
    saver.setup()
    return saver</code></pre>
</details>
</dd>
<dt id="satcamsim.save_output.Output_saver.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, obj, filename=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Save arbitrary objects.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>obj</code></strong> :&ensp;<code>object</code></dt>
<dd>The object to be stored. Must be pickleable.</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>file name of the stored object. If not provided, a number will be assigned as file name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, obj, filename=None):
    &#34;&#34;&#34;
    Save arbitrary objects.

    Parameters
    ----------
    obj : object
        The object to be stored. Must be pickleable.
    filename : str, optional
        file name of the stored object. If not provided, a number will be assigned as file name.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    if not filename:
        filename = str(self.file_counter)
    self.file_counter += 1

    with open(self.logfile, &#39;a&#39;) as log:
        log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: start saving &#39; + filename + &#39;\n&#39;)
    with open(self.out_folder + filename, &#39;wb&#39;) as pfile:
        pickle.dump(obj, pfile)
    with open(self.logfile, &#39;a&#39;) as log:
        log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: finished saving &#39; + filename + &#39;\n&#39;)</code></pre>
</details>
</dd>
<dt id="satcamsim.save_output.Output_saver.save_config"><code class="name flex">
<span>def <span class="ident">save_config</span></span>(<span>self, config)</span>
</code></dt>
<dd>
<div class="desc"><p>Save current config parameters in the log file. Parameters are read from the values in camera and input_imgs modules.</p>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_config(self, config):
    &#34;&#34;&#34;
    Save current config parameters in the log file. Parameters are read from the values in camera and input_imgs modules.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    with open(self.logfile, &#39;a&#39;) as log:
        log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: start saving config parameters\n&#39;)
        log.write(str(config) + &#39;\n&#39;)
        log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: finished saving config parameters\n&#39;)
    return</code></pre>
</details>
</dd>
<dt id="satcamsim.save_output.Output_saver.save_csv"><code class="name flex">
<span>def <span class="ident">save_csv</span></span>(<span>self, iterables, header=None, filename=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Save an iterable of iterables as a csv file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>iterables</code></strong> :&ensp;<code>Iterable[Iterable]</code></dt>
<dd>an Iterable containing the rows to be written to file.</dd>
<dt><strong><code>header</code></strong> :&ensp;<code>Iterable</code>, optional</dt>
<dd>an Iterable optionally specifying column headers. Must have len(header) == len(iterables).</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>name of the produced file. If not provided, a number will be assigned as file name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_csv(self, iterables, header=None, filename=None):
    &#34;&#34;&#34;
    Save an iterable of iterables as a csv file.

    Parameters
    ----------
    iterables : Iterable[Iterable]
        an Iterable containing the rows to be written to file.
    header : Iterable, optional
        an Iterable optionally specifying column headers. Must have len(header) == len(iterables).
    filename : str, optional
        name of the produced file. If not provided, a number will be assigned as file name.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    if not filename:
        filename = str(self.file_counter)
    self.file_counter += 1

    with open(self.out_folder + filename, &#39;w&#39;, newline=&#39;&#39;) as file:
        csv_writer = writer(file)

        if header:
            csv_writer.writerow(header)

        csv_writer.writerows(iterables)
    return</code></pre>
</details>
</dd>
<dt id="satcamsim.save_output.Output_saver.save_img"><code class="name flex">
<span>def <span class="ident">save_img</span></span>(<span>self, img, subfolder='', filename=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Save one or multiple images, single or multi-channel, contained within a single array.
Detailed behavior:
- if img.ndim &lt; 2: a warning is raised and img is pickled instead of saved as an image
- if img.ndim == 2: img saved as single-channel image
- if img.ndim == 3:
- if img.shape[0] == 1: img saved as single-channel image
- if img.shape[0] in (3, 4): img saved as RGB/RGBA image
- else: individual channels are saved as single-channel images in a subdirectory
- else: img[i] is passed into this function recursively, thus reducing img.ndim by one.
Log message is recorded accordingly.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>img</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>the array containing one or multiple images.</dd>
<dt><strong><code>subfolder</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>name of the subdirectory the image will bestored in, if . The default is ''.</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>file name of the stored image. Works only if img can be saved in a single file.
If not provided, a number will be assigned as file name.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="satcamsim.save_output.FolderExistsError" href="#satcamsim.save_output.FolderExistsError">FolderExistsError</a></code></dt>
<dd>if a subdirectory with the same name already exists.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_img(self, img, subfolder=&#39;&#39;, filename=None):
    &#34;&#34;&#34;
    Save one or multiple images, single or multi-channel, contained within a single array.
    Detailed behavior:
        - if img.ndim &lt; 2: a warning is raised and img is pickled instead of saved as an image
        - if img.ndim == 2: img saved as single-channel image
        - if img.ndim == 3:
            - if img.shape[0] == 1: img saved as single-channel image
            - if img.shape[0] in (3, 4): img saved as RGB/RGBA image
            - else: individual channels are saved as single-channel images in a subdirectory
        - else: img[i] is passed into this function recursively, thus reducing img.ndim by one.
    Log message is recorded accordingly.

    Parameters
    ----------
    img : np.ndarray
        the array containing one or multiple images.
    subfolder : str, optional
        name of the subdirectory the image will bestored in, if . The default is &#39;&#39;.
    filename : str, optional
        file name of the stored image. Works only if img can be saved in a single file.
        If not provided, a number will be assigned as file name.

    Raises
    ------
    FolderExistsError
        if a subdirectory with the same name already exists.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    if img.ndim &lt; 2:
        filename = &#39;failed_img_&#39; + str(self.file_counter)
        self.save(img, filename=filename)
        raise Warning(&#39;img must have img.ndim&gt;=2, was instead pickled as &#39; + filename)
        with open(self.logfile, &#39;a&#39;) as log:
            log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: array with ndim &lt; 2  could not be stored as image, pickled instead: &#39; + filename + &#39;\n&#39;)

    elif img.ndim == 2:
        self.save_img(img[None, :, :])

    elif img.ndim == 3:
        if img.shape[0] in (1, 3, 4):
            if not filename:
                filename = str(self.file_counter) + &#34;.tif&#34;
            with open(self.logfile, &#39;a&#39;) as log:
                log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: start saving &#39; + subfolder + filename + &#39;\n&#39;)
            im = Image.fromarray(img.swapaxes(0, 2).swapaxes(0, 1))
            im.save(self.out_folder + subfolder + filename)
            self.file_counter += 1
            with open(self.logfile, &#39;a&#39;) as log:
                log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: finished saving &#39; + subfolder + filename + &#39;\n&#39;)
        else:
            with open(self.logfile, &#39;a&#39;) as log:
                log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: array with no. of channels other than 1, 3, or 4 will be stored as individual images\n&#39;)
            try:
                os.mkdir(self.out_folder + str(self.file_counter) + &#39;\\&#39;)
            except FileExistsError:
                raise FolderExistsError(&#39;folder already exists: &#39; + self.out_folder + str(self.file_counter) + &#39;\\&#39;)
            [self.save_img(img[None, i, :, :], subfolder=str(self.file_counter) + &#39;\\&#39;, filename=str(i)) for i in range(img.shape[0])]

    else:
        with open(self.logfile, &#39;a&#39;) as log:
            log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: array ndim &gt; 3 will be stored as individual images\n&#39;)
        for i in range(img.shape[0]):
            self.save_img(img[i, :, :, :])
    return</code></pre>
</details>
</dd>
<dt id="satcamsim.save_output.Output_saver.save_imgs"><code class="name flex">
<span>def <span class="ident">save_imgs</span></span>(<span>self, imgs)</span>
</code></dt>
<dd>
<div class="desc"><p>Save an iterable containing images.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>imgs</code></strong> :&ensp;<code>iterable</code></dt>
<dd>Iterable containing the images to be saved.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_imgs(self, imgs):
    &#34;&#34;&#34;
    Save an iterable containing images.

    Parameters
    ----------
    imgs : iterable
        Iterable containing the images to be saved.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    for img in imgs:
        self.save_img(img)
    return</code></pre>
</details>
</dd>
<dt id="satcamsim.save_output.Output_saver.setup"><code class="name flex">
<span>def <span class="ident">setup</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create required files and directories.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="satcamsim.save_output.FolderExistsError" href="#satcamsim.save_output.FolderExistsError">FolderExistsError</a></code></dt>
<dd>Raised if directory already exists..</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup(self):
    &#34;&#34;&#34;
    Create required files and directories.

    Raises
    ------
    FolderExistsError
        Raised if directory already exists..

    Returns
    -------
    None.

    &#34;&#34;&#34;
    ident = time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;_output\\&#39;
    self.out_folder = self.parent_folder + ident
    try:
        os.mkdir(self.out_folder)
    except FileExistsError:
        raise FolderExistsError(&#39;folder already exists: &#39; + self.out_folder + str(self.file_counter) + &#39;\\&#39;)

    self.logfile = self.out_folder + &#39;log.txt&#39;
    with open(self.logfile, &#39;w&#39;) as log:
        log.write(time.strftime(&#39;%Y-%m-%d_%H-%M-%S&#39;) + &#39;: directory and log file created\n&#39;)

    self.file_counter = 1
    return</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="satcamsim.save_output.Temp_handler"><code class="flex name class">
<span>class <span class="ident">Temp_handler</span></span>
</code></dt>
<dd>
<div class="desc"><p>Handles saving, loading, and deletion of temp files. Ensures deletion of all files when exiting.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Temp_handler:
    &#34;&#34;&#34;Handles saving, loading, and deletion of temp files. Ensures deletion of all files when exiting.&#34;&#34;&#34;

    def __init__(self):
        self.files = []
        return

    def from_config(config):
        &#34;&#34;&#34;
        Initialize Temp_handler with config parameters.

        Parameters
        ----------
        config : Config
            Config instance containing desired parameters.

        Returns
        -------
        handler : Temp_handler
            initialized according to config parameters.

        &#34;&#34;&#34;
        handler = Temp_handler()
        handler.parent_folder = config[&#39;OUTPUT_FOLDER&#39;]
        return handler

    def __enter__(self):
        &#34;&#34;&#34;
        Create temp directories.

        Raises
        ------
        FolderExistsError
            if a directory with the same name already exists.

        Returns
        -------
        self : Temp_handler

        &#34;&#34;&#34;
        super_temp_folder = self.parent_folder + &#39;temp\\&#39;
        if not os.path.isdir(super_temp_folder):
            os.mkdir(super_temp_folder)

        temp_ident = str(uuid4())
        self.temp_folder = self.parent_folder + &#39;temp\\&#39; + temp_ident + &#39;\\&#39;

        try:
            os.mkdir(self.temp_folder)
        except FileExistsError:
            raise FolderExistsError(&#39;folder already exists: &#39; + self.temp_folder)

        return self

    def __exit__(self, exc_type, exc_value, traceback):
        &#34;&#34;&#34;
        Ensure deletion of all temp files when exiting context manager.

        Parameters
        ----------
        exc_type : exception type or None
            Type of exception raised within context manager, or None.
        exc_value : Exception or None
            The exception raised within context manager, or None.
        traceback : Traceback or None
            Traceback object for the raised exception, or None.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        if exc_type == FolderExistsError:
            return

        if os.path.isdir(self.temp_folder):
            rmtree(self.temp_folder)
        return

    def save(self, obj):
        &#34;&#34;&#34;
        Save an object to a temp file.

        Parameters
        ----------
        obj : object
            The object to be stored. Must be pickleable.

        Returns
        -------
        ident : str
            unique identifier to retrieve the object from memory.

        &#34;&#34;&#34;
        ident = str(uuid4())
        if os.path.exists(self.temp_folder + ident):
            raise FileExistsError(&#39;file already exists: &#39; + self.temp_folder + ident)
        with open(self.temp_folder + ident, &#39;wb&#39;) as pfile:
            pickle.dump(obj, pfile)
        self.files.append(ident)
        return ident

    def load(self, ident):
        &#34;&#34;&#34;
        Load an object stored in a temp file from memory.

        Parameters
        ----------
        ident : str
            the object&#39;s unique identifier returned when storing it.

        Returns
        -------
        obj : object
            the stored object.

        &#34;&#34;&#34;
        with open(self.temp_folder + ident, &#39;rb&#39;) as pfile:
            return pickle.load(pfile)

    def load_all(self):
        &#34;&#34;&#34;
        Load all objects stored in temp files by this Temp_handler.

        Returns
        -------
        objs: list
            contains all loaded objects in the order they were stored in.

        &#34;&#34;&#34;
        return [self.load(ident) for ident in self.files]

    def remove(self, ident):
        &#34;&#34;&#34;
        Delete a stored object from memory.

        Parameters
        ----------
        ident : str
            the object&#39;s unique identifier returned when storing it.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        os.remove(self.temp_folder + ident)
        self.files.remove(ident)
        return</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="satcamsim.save_output.Temp_handler.from_config"><code class="name flex">
<span>def <span class="ident">from_config</span></span>(<span>config)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize Temp_handler with config parameters.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>Config</code></dt>
<dd>Config instance containing desired parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>handler</code></strong> :&ensp;<code><a title="satcamsim.save_output.Temp_handler" href="#satcamsim.save_output.Temp_handler">Temp_handler</a></code></dt>
<dd>initialized according to config parameters.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_config(config):
    &#34;&#34;&#34;
    Initialize Temp_handler with config parameters.

    Parameters
    ----------
    config : Config
        Config instance containing desired parameters.

    Returns
    -------
    handler : Temp_handler
        initialized according to config parameters.

    &#34;&#34;&#34;
    handler = Temp_handler()
    handler.parent_folder = config[&#39;OUTPUT_FOLDER&#39;]
    return handler</code></pre>
</details>
</dd>
<dt id="satcamsim.save_output.Temp_handler.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self, ident)</span>
</code></dt>
<dd>
<div class="desc"><p>Load an object stored in a temp file from memory.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ident</code></strong> :&ensp;<code>str</code></dt>
<dd>the object's unique identifier returned when storing it.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>obj</code></strong> :&ensp;<code>object</code></dt>
<dd>the stored object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(self, ident):
    &#34;&#34;&#34;
    Load an object stored in a temp file from memory.

    Parameters
    ----------
    ident : str
        the object&#39;s unique identifier returned when storing it.

    Returns
    -------
    obj : object
        the stored object.

    &#34;&#34;&#34;
    with open(self.temp_folder + ident, &#39;rb&#39;) as pfile:
        return pickle.load(pfile)</code></pre>
</details>
</dd>
<dt id="satcamsim.save_output.Temp_handler.load_all"><code class="name flex">
<span>def <span class="ident">load_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Load all objects stored in temp files by this Temp_handler.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>objs</code></strong> :&ensp;<code>list</code></dt>
<dd>contains all loaded objects in the order they were stored in.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_all(self):
    &#34;&#34;&#34;
    Load all objects stored in temp files by this Temp_handler.

    Returns
    -------
    objs: list
        contains all loaded objects in the order they were stored in.

    &#34;&#34;&#34;
    return [self.load(ident) for ident in self.files]</code></pre>
</details>
</dd>
<dt id="satcamsim.save_output.Temp_handler.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, ident)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a stored object from memory.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ident</code></strong> :&ensp;<code>str</code></dt>
<dd>the object's unique identifier returned when storing it.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, ident):
    &#34;&#34;&#34;
    Delete a stored object from memory.

    Parameters
    ----------
    ident : str
        the object&#39;s unique identifier returned when storing it.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    os.remove(self.temp_folder + ident)
    self.files.remove(ident)
    return</code></pre>
</details>
</dd>
<dt id="satcamsim.save_output.Temp_handler.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, obj)</span>
</code></dt>
<dd>
<div class="desc"><p>Save an object to a temp file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>obj</code></strong> :&ensp;<code>object</code></dt>
<dd>The object to be stored. Must be pickleable.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ident</code></strong> :&ensp;<code>str</code></dt>
<dd>unique identifier to retrieve the object from memory.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, obj):
    &#34;&#34;&#34;
    Save an object to a temp file.

    Parameters
    ----------
    obj : object
        The object to be stored. Must be pickleable.

    Returns
    -------
    ident : str
        unique identifier to retrieve the object from memory.

    &#34;&#34;&#34;
    ident = str(uuid4())
    if os.path.exists(self.temp_folder + ident):
        raise FileExistsError(&#39;file already exists: &#39; + self.temp_folder + ident)
    with open(self.temp_folder + ident, &#39;wb&#39;) as pfile:
        pickle.dump(obj, pfile)
    self.files.append(ident)
    return ident</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="satcamsim" href="index.html">satcamsim</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="satcamsim.save_output.FolderExistsError" href="#satcamsim.save_output.FolderExistsError">FolderExistsError</a></code></h4>
</li>
<li>
<h4><code><a title="satcamsim.save_output.Output_saver" href="#satcamsim.save_output.Output_saver">Output_saver</a></code></h4>
<ul class="two-column">
<li><code><a title="satcamsim.save_output.Output_saver.from_config" href="#satcamsim.save_output.Output_saver.from_config">from_config</a></code></li>
<li><code><a title="satcamsim.save_output.Output_saver.save" href="#satcamsim.save_output.Output_saver.save">save</a></code></li>
<li><code><a title="satcamsim.save_output.Output_saver.save_config" href="#satcamsim.save_output.Output_saver.save_config">save_config</a></code></li>
<li><code><a title="satcamsim.save_output.Output_saver.save_csv" href="#satcamsim.save_output.Output_saver.save_csv">save_csv</a></code></li>
<li><code><a title="satcamsim.save_output.Output_saver.save_img" href="#satcamsim.save_output.Output_saver.save_img">save_img</a></code></li>
<li><code><a title="satcamsim.save_output.Output_saver.save_imgs" href="#satcamsim.save_output.Output_saver.save_imgs">save_imgs</a></code></li>
<li><code><a title="satcamsim.save_output.Output_saver.setup" href="#satcamsim.save_output.Output_saver.setup">setup</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="satcamsim.save_output.Temp_handler" href="#satcamsim.save_output.Temp_handler">Temp_handler</a></code></h4>
<ul class="">
<li><code><a title="satcamsim.save_output.Temp_handler.from_config" href="#satcamsim.save_output.Temp_handler.from_config">from_config</a></code></li>
<li><code><a title="satcamsim.save_output.Temp_handler.load" href="#satcamsim.save_output.Temp_handler.load">load</a></code></li>
<li><code><a title="satcamsim.save_output.Temp_handler.load_all" href="#satcamsim.save_output.Temp_handler.load_all">load_all</a></code></li>
<li><code><a title="satcamsim.save_output.Temp_handler.remove" href="#satcamsim.save_output.Temp_handler.remove">remove</a></code></li>
<li><code><a title="satcamsim.save_output.Temp_handler.save" href="#satcamsim.save_output.Temp_handler.save">save</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>