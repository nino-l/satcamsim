<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>satcamsim.input_imgs API documentation</title>
<meta name="description" content="Provides processor classes for reading and processing input data, and localizing GCPs." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>satcamsim.input_imgs</code></h1>
</header>
<section id="section-intro">
<p>Provides processor classes for reading and processing input data, and localizing GCPs.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Provides processor classes for reading and processing input data, and localizing GCPs.&#34;&#34;&#34;

import numpy as np
import rasterio
from rasterio import features, windows
from itertools import product
from shapely.geometry import Point, Polygon
from shapely.ops import unary_union
from os import listdir
import pyproj
import csv
from glob import glob


class Feature_finder:
    &#34;&#34;&#34;Find position of point features in simulated line scan image.

    The .csv containing 2D GCPs must have the format: `id,X,Y`.

    The .csv containing 3D GCPs must have the format: `id,X,Y,Z`.&#34;&#34;&#34;

    def __init__(self):
        self.names_2D = np.array([], dtype=object)
        self.points_2D = np.array([], dtype=object)
        self.coords_2D = np.empty((0, 2), dtype=float)

        self.names_3D = np.array([], dtype=object)
        self.points_3D = np.array([], dtype=object)
        self.coords_3D = np.empty((0, 3), dtype=float)

        self.Z_terrain = 0
        self.buffer = 0
        return

    def from_config(config):
        &#34;&#34;&#34;
        Initialize Feature_finder with config parameters.

        Parameters
        ----------
        config : Config
            Config instance containing desired parameters.

        Returns
        -------
        finder : Feature_finder
            initizialized Feature_finder instance.

        &#34;&#34;&#34;
        if not config[&#39;FIND_FEATURES&#39;]:
            return None

        finder = Feature_finder()
        finder.Z_terrain = config[&#39;MEAN_TERRAIN_HEIGHT&#39;]

        if config[&#39;FEATURE_CSV_PATH_2D&#39;]:
            filepath = config[&#39;FEATURE_CSV_PATH_2D&#39;]

            name_list = []
            coord_list = []
            point_list = []
            with open(filepath) as file:
                csv_reader = csv.reader(file)
                for row in csv_reader:
                    name_list.append(str(row[0]))
                    coords = (float(row[1]), float(row[2]))
                    point_list.append(Point(coords))
                    coord_list.append(coords)

            coord_list, point_list, name_list = zip(*sorted(zip(coord_list, point_list, name_list)))

            finder.coords_2D = np.array(coord_list)
            finder.names_2D = np.empty(len(name_list), dtype=object)
            finder.points_2D = np.empty(len(point_list), dtype=type(Point))
            for idx, (point, name) in enumerate(zip(point_list, name_list)):
                finder.points_2D[idx] = point
                finder.names_2D[idx] = name

        if config[&#39;FEATURE_CSV_PATH_3D&#39;]:
            filepath = config[&#39;FEATURE_CSV_PATH_3D&#39;]

            # read in 3D GCPs
            name_list = []
            coord_list = []
            point_list = []
            with open(filepath) as file:
                csv_reader = csv.reader(file)
                for row in csv_reader:
                    name_list.append(str(row[0]))
                    coords = (float(row[1]), float(row[2]), float(row[3]))
                    point_list.append(Point(coords))
                    coord_list.append(coords)

            coord_list, point_list, name_list = zip(*sorted(zip(coord_list, point_list, name_list)))

            finder.coords_3D = np.array(coord_list)     # fill array of point coordinates
            finder.names_3D = np.empty(len(name_list), dtype=object)
            finder.points_3D = np.empty(len(point_list), dtype=type(Point))
            for idx, (point, name) in enumerate(zip(point_list, name_list)):
                finder.points_3D[idx] = point           # fill array of Point objects
                finder.names_3D[idx] = name             # fill array of point names/identifiers as str

            approx_view_angle = np.deg2rad(config[&#39;APPROX_VIEW_ANGLE&#39;])
            max_roll = np.deg2rad(config[&#39;MAX_ROLL_ANGLE&#39;])

            # buffer to determine radius within which distorted 3D points may be found
            finder.buffer = np.max(np.abs(finder.coords_3D[:, 2] - finder.Z_terrain)) * np.tan(0.5 * approx_view_angle + max_roll)
        return finder

    def check(self, poly, vertices, line_idx, px_idx, sensor_name, pose):
        &#34;&#34;&#34;
        Check which of the Feature_finder&#39;s GCPs (if any) are contained within a polygon.

        Parameters
        ----------
        poly : Polygon
            Polygon to be checked.
        line_idx : int
            current pose.idx.
        px_idx : int
            current pixel&#39;s c coordinate.
        sensor_name : str
            current sensor&#39;s name.
        pose : Cam_pose
            current sensor&#39;s exterior orientation.

        Returns
        -------
        found_feats : list[tuple]
            list containing tuples with (GCP_name, line_idx, px_idx, sensor_name, GCP_X, GCP_Y, GCP_Z) of all GCPs contained in poly.
            GCPs without Z information are marked with GCP_Z = 999999.

        &#34;&#34;&#34;
        X_min, Y_min, X_max, Y_max = poly.bounds

        candidate_idxs = self._get_candidates_2D(X_min, Y_min, X_max, Y_max)
        # create list with tuple of format: (feature_name, row, column, sensor_name, feature_X, feature_Y, 999999)
        found_feats_2D = [(point_name, line_idx, px_idx, sensor_name, point_coords[0], point_coords[1], 999999) for point_name, point_coords, point in zip(self.names_2D[candidate_idxs], self.coords_2D[candidate_idxs], self.points_2D[candidate_idxs]) if poly.contains(point)]

        candidate_idxs = self._get_candidates_3D(X_min, Y_min, X_max, Y_max)
        # create list with tuple of format: (feature_name, row, column, sensor_name, feature_X, feature_Y, feature_Z)
        found_feats_3D = [(point_name, line_idx, px_idx, sensor_name, point_coords[0], point_coords[1], point_coords[2]) for point_name, point_coords, point in zip(self.names_3D[candidate_idxs], self.coords_3D[candidate_idxs], self.points_3D[candidate_idxs]) if self._get_poly_Z(vertices, point_coords[2], pose).contains(point)]

        return found_feats_2D + found_feats_3D

    def _get_candidates_3D(self, X_min, Y_min, X_max, Y_max):
        &#34;&#34;&#34;Preselect GCPs based on rectangular bounding box and buffer zone.&#34;&#34;&#34;
        start_idx = np.searchsorted(self.coords_3D[:, 0], X_min - self.buffer)
        stop_idx = start_idx + np.searchsorted(self.coords_3D[start_idx:, 0], X_max + self.buffer, &#39;right&#39;)

        candidate_idxs = start_idx + np.where(np.logical_and(self.coords_3D[start_idx:stop_idx, 1] &gt;= Y_min - self.buffer, self.coords_3D[start_idx:stop_idx, 1] &lt;= Y_max + self.buffer))[0]

        return candidate_idxs

    def _get_candidates_2D(self, X_min, Y_min, X_max, Y_max):
        &#34;&#34;&#34;Preselect GCPs based on rectangular bounding box.&#34;&#34;&#34;
        start_idx = np.searchsorted(self.coords_2D[:, 0], X_min)
        stop_idx = start_idx + np.searchsorted(self.coords_2D[start_idx:, 0], X_max, &#39;right&#39;)

        candidate_idxs = start_idx + np.where(np.logical_and(self.coords_2D[start_idx:stop_idx, 1] &gt;= Y_min, self.coords_2D[start_idx:stop_idx, 1] &lt;= Y_max))[0]

        return candidate_idxs

    def _get_ray_at_Z(self, point, proj_center, Z):
        &#34;&#34;&#34;Ray tracing for 3D GCP detection. Returns X, Y position of ray passing through point and proj_center at elevation Z.&#34;&#34;&#34;
        deltaZ = proj_center[2] - self.Z_terrain
        deltas = (proj_center[0:2] - point) / deltaZ
        X, Y = point + deltas * (Z - self.Z_terrain)
        return X, Y

    def _get_poly_Z(self, vertices, Z, pose):
        &#34;&#34;&#34;Create new Polygon at a candidate GCP&#39;s Z elevation to determine whether it is inside FOV.&#34;&#34;&#34;
        new_center = pose.XYZ_0
        old_center = pose.previous.XYZ_0
        poly_Z = Polygon([self._get_ray_at_Z(vertices[0], new_center, Z),
                          self._get_ray_at_Z(vertices[1], old_center, Z),
                          self._get_ray_at_Z(vertices[2], old_center, Z),
                          self._get_ray_at_Z(vertices[3], new_center, Z)])
        return poly_Z


class Comp_processor:
    &#34;&#34;&#34;Facilitate and simplify operations involving raster data used as comparison.&#34;&#34;&#34;

    def __init__(self):
        self.open_files = dict()
        return

    def from_config(config, folder_out):
        &#34;&#34;&#34;
        Initialize Comp_processor with config parameters.

        Parameters
        ----------
        config : Config
            Config specifying the processor parameters.
        folder_out : str
            Path to output folder for the processor.

        Returns
        -------
        processor : Comp_processor
            The initialized processor.

        &#34;&#34;&#34;
        processor = Comp_processor()
        processor.folder_in = config[&#39;COMPARE_FOLDER&#39;]
        processor.filenames = config[&#39;COMP_FILES&#39;]

        # create coordinate reference system
        processor.crs_obj = config[&#39;CRS_IN&#39;]

        processor.folder_out = folder_out

        processor.glue_multipolys = config[&#39;GLUE_MULTIPOLYS&#39;]
        if processor.glue_multipolys:
            processor.max_dist_glue = config[&#39;MAX_DIST_GLUE&#39;]
            processor.max_iter_glue = config[&#39;MAX_ITER_GLUE&#39;]
            processor.glue_dist = processor.max_dist_glue / processor.max_iter_glue

        return processor

    def __del__(self):
        &#34;&#34;&#34;
        Guarantee that all files are closed before deletion.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        for _, file in self.open_files.items():
            file.close()
        return

    def __enter__(self):
        &#34;&#34;&#34;
        Open comparison files for use in context manager.

        Returns
        -------
        self : Comp_processor
            The Comp_processor instance created for the context manager.

        &#34;&#34;&#34;
        if not self.filenames:
            self.filenames = listdir(self.folder_in)
        for filename in self.filenames:
            self._open_file(filename)

        return self

    def __exit__(self, exc_type, exc_value, traceback):
        &#34;&#34;&#34;
        Ensure proper closing of all files when exiting context manager.

        Parameters
        ----------
        exc_type : exception type or None
            Type of exception raised within context manager, or None.
        exc_value : Exception or None
            The exception raised within context manager, or None.
        traceback : Traceback or None
            Traceback object for the raised exception, or None.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        for _, file in self.open_files.items():
            file.close()
        return

    def _open_file(self, filename):
        &#34;&#34;&#34;
        Open specified files from disk.

        Parameters
        ----------
        filename : str
            name of file to be loaded.

        Returns
        -------
        flag : bool
            True if file was successfully opened, False otherwise.

        &#34;&#34;&#34;
        if filename not in self.open_files:
            try:
                self.open_files[filename] = rasterio.open(self.folder_in + filename)
            except rasterio.errors.RasterioIOError:     # raised if required file not available or not a valid raster file
                print(&#34;\r&#34; + &#34;Warning: File &#34; + self.folder_in + filename + &#34; not found or could not be opened by rasterio!&#34;, end=&#34;&#34;)
                return False
        return True

    def read_from_file(self, region_to_cut, file):
        &#34;&#34;&#34;
        Reads data contained in the specified region from file.

        Parameters
        ----------
        region_to_cut : Polygon
            Region of interest, in XY object coordinates.
        file : rasterio.DatasetReader
            file from which data is to be read.

        Returns
        -------
        contained_data : np.ndarray
            extracted raster data.
        window_trans : rasterio.affine.Affine
            transform of the extracted raster data section.

        &#34;&#34;&#34;
        X_min, Y_min, X_max, Y_max = region_to_cut.bounds
        poly_window = windows.from_bounds(X_min, Y_min, X_max, Y_max, transform=file.transform)
        window_trans = windows.transform(poly_window, file.transform)
        data = file.read(window=poly_window)
        
        nodata = file.nodatavals[0]
        if nodata is None:
            nodata = 0

        # determine contained pixels
        contained = features.rasterize([(region_to_cut, 1)], out_shape=data.shape[1:], fill=0, transform=window_trans)
        contained_data = np.where(contained, data, nodata)
        return contained_data, window_trans

    def cut_geom(self, geom):
        &#34;&#34;&#34;
        Cut and save region of passed-in geometry object from raster data.
        The specified geometry is cropped to the edges of the raster data, if necessary.
        Output is saved to the Comp_processor&#39;s folder_out.

        Parameters
        ----------
        geom : shapely.geometry object
            geometry object describing the region to be extracted, in EPSG:25832 coordinates.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        with rasterio.Env() as rio_env:
            if self.glue_multipolys:
                geom = self.glue_geoms(geom)    # close small gaps in the coverage

            for filename, file in self.open_files.items():
                
                # CRS transformation
                crs_comp = pyproj.CRS.from_user_input(file.crs)
                obj2comp = pyproj.transformer.Transformer.from_crs(self.crs_obj, crs_comp)
                
                # transform geom to comparison data CRS
                vert_coords_transformed = list(obj2comp.itransform(geom.exterior.coords))
                vertices_transformed = [Point(X, Y) for X, Y in vert_coords_transformed]
                geom_transformed = Polygon(vertices_transformed)
                
                # crop region to edges of comparison data
                X_lo, Y_lo, X_hi, Y_hi = file.bounds
                region_to_cut = geom_transformed.intersection(Polygon([(X_lo, Y_lo), (X_hi, Y_lo), (X_hi, Y_hi), (X_lo, Y_hi)]))

                # if no overlap exists
                if not region_to_cut:
                    continue

                contained_data, window_trans = self.read_from_file(region_to_cut, file)
                # write to new raster file
                profile = file.profile
                profile.update(height=contained_data.shape[1],
                               width=contained_data.shape[2],
                               transform=window_trans)
                with rasterio.open(self.folder_out + &#39;cutout_&#39; + filename, &#39;w&#39;, **profile) as dest:
                    for idx, band_data in enumerate(contained_data, start=1):
                        dest.write(band_data, idx)
        return

    def glue_geoms(self, geom):
        &#34;&#34;&#34;
        Dilate a collection of geometries iteratively until its members can be merged into a single Polygon.
        If a single, non-Polygon geometry object is passed, it is dilated and therefore converted to a Polygon.
        If not all members can be unified into a single Polygon within the dilation limits, an exception is raised.

        Parameters
        ----------
        geom : shapely.geometry object
            geometry collection or single geometry object.

        Returns
        -------
        geom : shapely.geometry object
            single Polygon, if glueing was successful.

        &#34;&#34;&#34;
        if isinstance(geom, Polygon):
            return geom
        
        for _ in range(self.max_iter_glue):
            geom = geom.buffer(self.glue_dist, resolution=4, cap_style=3, join_style=3)     # dilate by self.glue_dist
            geom = unary_union([geom])      # try unifiying all members

            if isinstance(geom, Polygon):
                return geom

        raise ValueError(&#34;Dilation limit reached, geometry could not be unified into a single Polygon&#34;)


class Input_processor:
    &#34;&#34;&#34;
    Facilitate and simplify operations involving the input images.

    Parameters
    ----------
    bands : tuple of int
        the band indices to be read from the input data.

    Returns
    -------
    Input_processor : Input_processor
        a new Input_processor instance.

    &#34;&#34;&#34;

    def __init__(self):
        self.open_files = dict()
        self.available_files = np.array([], dtype=object)
        self.bounds = np.empty((0, 4), dtype=float)
        return

    def from_config(config):
        &#34;&#34;&#34;
        Initialize a new Input_processor with the parameters specified in config.

        Parameters
        ----------
        config : Config
            Config containing all relevant parameters.

        Returns
        -------
        processor : Input_processor
            The initialized Input_processor instance.

        &#34;&#34;&#34;
        processor = Input_processor()
        processor.max_open_files = config[&#39;MAX_OPEN_FILES&#39;]
        processor.folder_in = config[&#39;FOLDER_IN&#39;]
        processor.file_extension = config[&#39;FILEEXTENSION_IN&#39;]
        processor.nodata = config[&#39;NODATA_IN&#39;]
        return processor

    def __del__(self):
        &#34;&#34;&#34;
        Guarantee that all files are closed before deletion.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        for _, file in self.open_files.items():
            file.close()
        return

    def __enter__(self):
        &#34;&#34;&#34;
        Return self for use in context manager.

        Returns
        -------
        self : Input_processor
            The Input_processor instance for the context manager.

        &#34;&#34;&#34;
        self.available_files = np.array(glob(self.folder_in + &#39;*&#39; + self.file_extension))
        
        self.bounds = np.full((len(self.available_files), 4), np.nan, dtype=float)
        for idx, file in enumerate(self.available_files):
            with rasterio.open(file) as f:
                self.bounds[idx, :] = f.bounds
                
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        &#34;&#34;&#34;
        Ensure proper closing of all files when exiting context manager.

        Parameters
        ----------
        exc_type : exception type or None
            Type of exception raised within context manager, or None.
        exc_value : Exception or None
            The exception raised within context manager, or None.
        traceback : Traceback or None
            Traceback object for the raised exception, or None.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        for _, file in self.open_files.items():
            file.close()
        return

    def sample_area(self, corners_obj, bands):
        &#34;&#34;&#34;
        Compute mean of raster data within the polygonal area specified by its corners in object coordinates.

        Parameters
        ----------
        corners_obj: list of tuple
            list of (X, Y) coordinate tuples representing polygon corners.
        bands : tuple of int
            tuple of the band indices to be read.

        Returns
        -------
        flag : bool
            True if sampling was successful for all requested bands, False otherwise.
        sample : np.array or None
            array of shape (n_bands,) containing mean values for each band if sampling was successful, None otherwise.
        poly : shapely.geometry.Polygon
            the polygon area that was sampled (=ground track coverage). Returned even if sampling was unsuccessful.

        &#34;&#34;&#34;
        # create polygon of area of pixel projected onto terrain
        poly = Polygon(corners_obj)

        is_success, data_list, trans_list = self.read_data(poly, corners_obj, bands)

        if not is_success:
            return False, None, poly
        
        sum_samples = np.zeros((len(bands),), dtype=float)
        num_samples = 0.
        for data, data_trans in zip(data_list, trans_list):
            # determine contained input pixels in read-in data
            contained = features.rasterize([(poly, 1)], out_shape=data.shape[1:], fill=0, transform=data_trans)
            
            # check nodata
            data = data[:, contained.astype(bool)]
            if self.nodata in data:
                return False, None, poly
    
            sum_samples += data.sum(axis=1)        # sum sampled pixel values per band
            num_samples += contained.sum()         # no. of sampled pixels

        sample = sum_samples / num_samples        # compute mean sampled pixel values

        return True, sample, poly

    def get_filenames(self, objcoords):
        &#34;&#34;&#34;
        Construct all file names containing specified points.

        Parameters
        ----------
        objcoords : list[tuple]
            list of point coordinate tuples in (X, Y) format.

        Returns
        -------
        filenames : list[str]
            contains unique names of the files, ordered by ascending X, if equal by ascending Y positions.

        &#34;&#34;&#34;
        if not hasattr(objcoords[0], &#34;__len__&#34;):    # if a single point is specified instead of list of points
            return self.get_filenames([objcoords])

        filenames = list()
        
        objcoords = sorted(objcoords)
        for X, Y in objcoords:
            fname = self.available_files[(self.bounds[:, 0] &lt;= X) &amp;  (self.bounds[:, 1] &lt;= Y) &amp; (X &lt;= self.bounds[:, 2]) &amp; (Y &lt;= self.bounds[:, 3])]
            if len(fname) != 1:
                # if file could not be uniquely identified
                return False, None
            
            filenames.append(fname[0])
            
        filenames = list(dict.fromkeys(filenames))  # keep only unique filenames while preserving order
        return True, filenames

    def _open_file(self, filename):
        &#34;&#34;&#34;
        Open specified files from disk.

        Parameters
        ----------
        filename : str
            name of file to be loaded.

        Returns
        -------
        flag : bool
            True if file was successfully opened, False otherwise.

        &#34;&#34;&#34;
        if filename not in self.open_files:
            if len(self.open_files) &gt;= self.max_open_files:
                self._close_files(len(self.open_files) - self.max_open_files)

            self.open_files[filename] = rasterio.open(filename)
        return

    def read_data(self, poly, vertices, bands):
        &#34;&#34;&#34;
        Read a rectangular bounding box containing the specified Polygon from input files.
        The current implementation may break if input files use a CRS/transform where not X==East==right, Y==North==up.

        Parameters
        ----------
        poly : shapely.geometry.Polygon
            Polygonal ROI which will be fully covered by the read-in data.
        vertices : np.ndarray
            coordinates of ROI vertices.
        bands : tuple of int
             tuple of the band indices to be read.

        Returns
        -------
        flag : bool
            True if data was read in successfully, False otherwise.
        data : np.ndarray or None
            raster data contained in the rectangular bounding box around poly, if successful. None otherwise.
        data_trans : rasterio.affine.Affine or None
            Affine transform from raster data pixels to object coordinates, if successful. None otherwise.

        &#34;&#34;&#34;
        polybounds = poly.bounds
        
        # determine required input files from bounding box corners and try to load them if necessary
        all_files_found, filenames = self.get_filenames([polybounds[0:2],       # SW corner    (yes
                                                         polybounds[0::3],      # NW corner     this
                                                         polybounds[2:0:-1],    # SE corner     is
                                                         polybounds[2:]])       # NE corner     ugly)
        
        if not all_files_found:
            # if coordinates could not be assigned to a unique input file
            return False, None, None
        
        for filename in filenames:
            if filename not in self.open_files:
                self._open_file(filename)
        
        if len(filenames) == 1:
            file = self.open_files[filenames[0]]
            # windowed reading from input file
            poly_window = windows.from_bounds(*polybounds, transform=file.transform)
            data_trans = windows.transform(poly_window, file.transform)
            data = file.read(bands, window=poly_window)
            
            if 0 in data.shape:
                # can happen if only a very thin (&lt; 0.5 input pixels) part of the poly intersects with the input images
                return False, None, None
            return True, [data], [data_trans]

        data_list = []
        trans_list = []
        for filename in filenames:
            file = self.open_files[filename]
            
            # trim bounding box to not extend beyond limits of the file
            # (this will absolutely break if file uses a weird CRS/transform where not X==East==right, Y==North==up:
            # rasterio orders file.bounds as &#39;left, bottom, right, top&#39;, which is not necessarily the same as &#39;X_min, Y_min, X_max, Y_max&#39;.
            # thats&#39;s what geodesysts get for inventing stupid coordinate systems with insane axis ordering, and frankly I won&#39;t clean their mess for them)
            windowbounds = [max(polymin, filemin) for polymin, filemin in zip(polybounds[:2], file.bounds[:2])] + [min(polymax, filemax) for polymax, filemax in zip(polybounds[2:], file.bounds[2:])]

            # windowed reading from input file
            poly_window = windows.from_bounds(*windowbounds, transform=file.transform)
            data_trans = windows.transform(poly_window, file.transform)
            data = file.read(bands, window=poly_window)

            if 0 in data.shape:
                # can happen if only a very thin (&lt; 0.5 input pixels) part of the poly intersects with the input images
                continue
            
            data_list.append(data)
            trans_list.append(data_trans)

        return True, data_list, trans_list

    def _close_files(self, n_files=-1):
        &#34;&#34;&#34;
        Close files that have been open the longest (oldest file in dict).

        Parameters
        ----------
        n_files : int, optional
            Number of files to close, or -1 to close all files. The default is -1.
            Note: if n_files &gt;= len(self.open_files), all files will be closed.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        if n_files == -1 or n_files &gt; len(self.open_files):
            n_files = len(self.open_files)

        for _ in range(n_files):
            filename, file = next(iter(self.open_files.items()))
            file.close()
            del self.open_files[filename]
        return</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="satcamsim.input_imgs.Comp_processor"><code class="flex name class">
<span>class <span class="ident">Comp_processor</span></span>
</code></dt>
<dd>
<div class="desc"><p>Facilitate and simplify operations involving raster data used as comparison.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Comp_processor:
    &#34;&#34;&#34;Facilitate and simplify operations involving raster data used as comparison.&#34;&#34;&#34;

    def __init__(self):
        self.open_files = dict()
        return

    def from_config(config, folder_out):
        &#34;&#34;&#34;
        Initialize Comp_processor with config parameters.

        Parameters
        ----------
        config : Config
            Config specifying the processor parameters.
        folder_out : str
            Path to output folder for the processor.

        Returns
        -------
        processor : Comp_processor
            The initialized processor.

        &#34;&#34;&#34;
        processor = Comp_processor()
        processor.folder_in = config[&#39;COMPARE_FOLDER&#39;]
        processor.filenames = config[&#39;COMP_FILES&#39;]

        # create coordinate reference system
        processor.crs_obj = config[&#39;CRS_IN&#39;]

        processor.folder_out = folder_out

        processor.glue_multipolys = config[&#39;GLUE_MULTIPOLYS&#39;]
        if processor.glue_multipolys:
            processor.max_dist_glue = config[&#39;MAX_DIST_GLUE&#39;]
            processor.max_iter_glue = config[&#39;MAX_ITER_GLUE&#39;]
            processor.glue_dist = processor.max_dist_glue / processor.max_iter_glue

        return processor

    def __del__(self):
        &#34;&#34;&#34;
        Guarantee that all files are closed before deletion.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        for _, file in self.open_files.items():
            file.close()
        return

    def __enter__(self):
        &#34;&#34;&#34;
        Open comparison files for use in context manager.

        Returns
        -------
        self : Comp_processor
            The Comp_processor instance created for the context manager.

        &#34;&#34;&#34;
        if not self.filenames:
            self.filenames = listdir(self.folder_in)
        for filename in self.filenames:
            self._open_file(filename)

        return self

    def __exit__(self, exc_type, exc_value, traceback):
        &#34;&#34;&#34;
        Ensure proper closing of all files when exiting context manager.

        Parameters
        ----------
        exc_type : exception type or None
            Type of exception raised within context manager, or None.
        exc_value : Exception or None
            The exception raised within context manager, or None.
        traceback : Traceback or None
            Traceback object for the raised exception, or None.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        for _, file in self.open_files.items():
            file.close()
        return

    def _open_file(self, filename):
        &#34;&#34;&#34;
        Open specified files from disk.

        Parameters
        ----------
        filename : str
            name of file to be loaded.

        Returns
        -------
        flag : bool
            True if file was successfully opened, False otherwise.

        &#34;&#34;&#34;
        if filename not in self.open_files:
            try:
                self.open_files[filename] = rasterio.open(self.folder_in + filename)
            except rasterio.errors.RasterioIOError:     # raised if required file not available or not a valid raster file
                print(&#34;\r&#34; + &#34;Warning: File &#34; + self.folder_in + filename + &#34; not found or could not be opened by rasterio!&#34;, end=&#34;&#34;)
                return False
        return True

    def read_from_file(self, region_to_cut, file):
        &#34;&#34;&#34;
        Reads data contained in the specified region from file.

        Parameters
        ----------
        region_to_cut : Polygon
            Region of interest, in XY object coordinates.
        file : rasterio.DatasetReader
            file from which data is to be read.

        Returns
        -------
        contained_data : np.ndarray
            extracted raster data.
        window_trans : rasterio.affine.Affine
            transform of the extracted raster data section.

        &#34;&#34;&#34;
        X_min, Y_min, X_max, Y_max = region_to_cut.bounds
        poly_window = windows.from_bounds(X_min, Y_min, X_max, Y_max, transform=file.transform)
        window_trans = windows.transform(poly_window, file.transform)
        data = file.read(window=poly_window)
        
        nodata = file.nodatavals[0]
        if nodata is None:
            nodata = 0

        # determine contained pixels
        contained = features.rasterize([(region_to_cut, 1)], out_shape=data.shape[1:], fill=0, transform=window_trans)
        contained_data = np.where(contained, data, nodata)
        return contained_data, window_trans

    def cut_geom(self, geom):
        &#34;&#34;&#34;
        Cut and save region of passed-in geometry object from raster data.
        The specified geometry is cropped to the edges of the raster data, if necessary.
        Output is saved to the Comp_processor&#39;s folder_out.

        Parameters
        ----------
        geom : shapely.geometry object
            geometry object describing the region to be extracted, in EPSG:25832 coordinates.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        with rasterio.Env() as rio_env:
            if self.glue_multipolys:
                geom = self.glue_geoms(geom)    # close small gaps in the coverage

            for filename, file in self.open_files.items():
                
                # CRS transformation
                crs_comp = pyproj.CRS.from_user_input(file.crs)
                obj2comp = pyproj.transformer.Transformer.from_crs(self.crs_obj, crs_comp)
                
                # transform geom to comparison data CRS
                vert_coords_transformed = list(obj2comp.itransform(geom.exterior.coords))
                vertices_transformed = [Point(X, Y) for X, Y in vert_coords_transformed]
                geom_transformed = Polygon(vertices_transformed)
                
                # crop region to edges of comparison data
                X_lo, Y_lo, X_hi, Y_hi = file.bounds
                region_to_cut = geom_transformed.intersection(Polygon([(X_lo, Y_lo), (X_hi, Y_lo), (X_hi, Y_hi), (X_lo, Y_hi)]))

                # if no overlap exists
                if not region_to_cut:
                    continue

                contained_data, window_trans = self.read_from_file(region_to_cut, file)
                # write to new raster file
                profile = file.profile
                profile.update(height=contained_data.shape[1],
                               width=contained_data.shape[2],
                               transform=window_trans)
                with rasterio.open(self.folder_out + &#39;cutout_&#39; + filename, &#39;w&#39;, **profile) as dest:
                    for idx, band_data in enumerate(contained_data, start=1):
                        dest.write(band_data, idx)
        return

    def glue_geoms(self, geom):
        &#34;&#34;&#34;
        Dilate a collection of geometries iteratively until its members can be merged into a single Polygon.
        If a single, non-Polygon geometry object is passed, it is dilated and therefore converted to a Polygon.
        If not all members can be unified into a single Polygon within the dilation limits, an exception is raised.

        Parameters
        ----------
        geom : shapely.geometry object
            geometry collection or single geometry object.

        Returns
        -------
        geom : shapely.geometry object
            single Polygon, if glueing was successful.

        &#34;&#34;&#34;
        if isinstance(geom, Polygon):
            return geom
        
        for _ in range(self.max_iter_glue):
            geom = geom.buffer(self.glue_dist, resolution=4, cap_style=3, join_style=3)     # dilate by self.glue_dist
            geom = unary_union([geom])      # try unifiying all members

            if isinstance(geom, Polygon):
                return geom

        raise ValueError(&#34;Dilation limit reached, geometry could not be unified into a single Polygon&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="satcamsim.input_imgs.Comp_processor.cut_geom"><code class="name flex">
<span>def <span class="ident">cut_geom</span></span>(<span>self, geom)</span>
</code></dt>
<dd>
<div class="desc"><p>Cut and save region of passed-in geometry object from raster data.
The specified geometry is cropped to the edges of the raster data, if necessary.
Output is saved to the Comp_processor's folder_out.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>geom</code></strong> :&ensp;<code>shapely.geometry object</code></dt>
<dd>geometry object describing the region to be extracted, in EPSG:25832 coordinates.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cut_geom(self, geom):
    &#34;&#34;&#34;
    Cut and save region of passed-in geometry object from raster data.
    The specified geometry is cropped to the edges of the raster data, if necessary.
    Output is saved to the Comp_processor&#39;s folder_out.

    Parameters
    ----------
    geom : shapely.geometry object
        geometry object describing the region to be extracted, in EPSG:25832 coordinates.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    with rasterio.Env() as rio_env:
        if self.glue_multipolys:
            geom = self.glue_geoms(geom)    # close small gaps in the coverage

        for filename, file in self.open_files.items():
            
            # CRS transformation
            crs_comp = pyproj.CRS.from_user_input(file.crs)
            obj2comp = pyproj.transformer.Transformer.from_crs(self.crs_obj, crs_comp)
            
            # transform geom to comparison data CRS
            vert_coords_transformed = list(obj2comp.itransform(geom.exterior.coords))
            vertices_transformed = [Point(X, Y) for X, Y in vert_coords_transformed]
            geom_transformed = Polygon(vertices_transformed)
            
            # crop region to edges of comparison data
            X_lo, Y_lo, X_hi, Y_hi = file.bounds
            region_to_cut = geom_transformed.intersection(Polygon([(X_lo, Y_lo), (X_hi, Y_lo), (X_hi, Y_hi), (X_lo, Y_hi)]))

            # if no overlap exists
            if not region_to_cut:
                continue

            contained_data, window_trans = self.read_from_file(region_to_cut, file)
            # write to new raster file
            profile = file.profile
            profile.update(height=contained_data.shape[1],
                           width=contained_data.shape[2],
                           transform=window_trans)
            with rasterio.open(self.folder_out + &#39;cutout_&#39; + filename, &#39;w&#39;, **profile) as dest:
                for idx, band_data in enumerate(contained_data, start=1):
                    dest.write(band_data, idx)
    return</code></pre>
</details>
</dd>
<dt id="satcamsim.input_imgs.Comp_processor.from_config"><code class="name flex">
<span>def <span class="ident">from_config</span></span>(<span>config, folder_out)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize Comp_processor with config parameters.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>Config</code></dt>
<dd>Config specifying the processor parameters.</dd>
<dt><strong><code>folder_out</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to output folder for the processor.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>processor</code></strong> :&ensp;<code><a title="satcamsim.input_imgs.Comp_processor" href="#satcamsim.input_imgs.Comp_processor">Comp_processor</a></code></dt>
<dd>The initialized processor.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_config(config, folder_out):
    &#34;&#34;&#34;
    Initialize Comp_processor with config parameters.

    Parameters
    ----------
    config : Config
        Config specifying the processor parameters.
    folder_out : str
        Path to output folder for the processor.

    Returns
    -------
    processor : Comp_processor
        The initialized processor.

    &#34;&#34;&#34;
    processor = Comp_processor()
    processor.folder_in = config[&#39;COMPARE_FOLDER&#39;]
    processor.filenames = config[&#39;COMP_FILES&#39;]

    # create coordinate reference system
    processor.crs_obj = config[&#39;CRS_IN&#39;]

    processor.folder_out = folder_out

    processor.glue_multipolys = config[&#39;GLUE_MULTIPOLYS&#39;]
    if processor.glue_multipolys:
        processor.max_dist_glue = config[&#39;MAX_DIST_GLUE&#39;]
        processor.max_iter_glue = config[&#39;MAX_ITER_GLUE&#39;]
        processor.glue_dist = processor.max_dist_glue / processor.max_iter_glue

    return processor</code></pre>
</details>
</dd>
<dt id="satcamsim.input_imgs.Comp_processor.glue_geoms"><code class="name flex">
<span>def <span class="ident">glue_geoms</span></span>(<span>self, geom)</span>
</code></dt>
<dd>
<div class="desc"><p>Dilate a collection of geometries iteratively until its members can be merged into a single Polygon.
If a single, non-Polygon geometry object is passed, it is dilated and therefore converted to a Polygon.
If not all members can be unified into a single Polygon within the dilation limits, an exception is raised.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>geom</code></strong> :&ensp;<code>shapely.geometry object</code></dt>
<dd>geometry collection or single geometry object.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>geom</code></strong> :&ensp;<code>shapely.geometry object</code></dt>
<dd>single Polygon, if glueing was successful.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def glue_geoms(self, geom):
    &#34;&#34;&#34;
    Dilate a collection of geometries iteratively until its members can be merged into a single Polygon.
    If a single, non-Polygon geometry object is passed, it is dilated and therefore converted to a Polygon.
    If not all members can be unified into a single Polygon within the dilation limits, an exception is raised.

    Parameters
    ----------
    geom : shapely.geometry object
        geometry collection or single geometry object.

    Returns
    -------
    geom : shapely.geometry object
        single Polygon, if glueing was successful.

    &#34;&#34;&#34;
    if isinstance(geom, Polygon):
        return geom
    
    for _ in range(self.max_iter_glue):
        geom = geom.buffer(self.glue_dist, resolution=4, cap_style=3, join_style=3)     # dilate by self.glue_dist
        geom = unary_union([geom])      # try unifiying all members

        if isinstance(geom, Polygon):
            return geom

    raise ValueError(&#34;Dilation limit reached, geometry could not be unified into a single Polygon&#34;)</code></pre>
</details>
</dd>
<dt id="satcamsim.input_imgs.Comp_processor.read_from_file"><code class="name flex">
<span>def <span class="ident">read_from_file</span></span>(<span>self, region_to_cut, file)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads data contained in the specified region from file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>region_to_cut</code></strong> :&ensp;<code>Polygon</code></dt>
<dd>Region of interest, in XY object coordinates.</dd>
<dt><strong><code>file</code></strong> :&ensp;<code>rasterio.DatasetReader</code></dt>
<dd>file from which data is to be read.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>contained_data</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>extracted raster data.</dd>
<dt><strong><code>window_trans</code></strong> :&ensp;<code>rasterio.affine.Affine</code></dt>
<dd>transform of the extracted raster data section.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_from_file(self, region_to_cut, file):
    &#34;&#34;&#34;
    Reads data contained in the specified region from file.

    Parameters
    ----------
    region_to_cut : Polygon
        Region of interest, in XY object coordinates.
    file : rasterio.DatasetReader
        file from which data is to be read.

    Returns
    -------
    contained_data : np.ndarray
        extracted raster data.
    window_trans : rasterio.affine.Affine
        transform of the extracted raster data section.

    &#34;&#34;&#34;
    X_min, Y_min, X_max, Y_max = region_to_cut.bounds
    poly_window = windows.from_bounds(X_min, Y_min, X_max, Y_max, transform=file.transform)
    window_trans = windows.transform(poly_window, file.transform)
    data = file.read(window=poly_window)
    
    nodata = file.nodatavals[0]
    if nodata is None:
        nodata = 0

    # determine contained pixels
    contained = features.rasterize([(region_to_cut, 1)], out_shape=data.shape[1:], fill=0, transform=window_trans)
    contained_data = np.where(contained, data, nodata)
    return contained_data, window_trans</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="satcamsim.input_imgs.Feature_finder"><code class="flex name class">
<span>class <span class="ident">Feature_finder</span></span>
</code></dt>
<dd>
<div class="desc"><p>Find position of point features in simulated line scan image.</p>
<p>The .csv containing 2D GCPs must have the format: <code>id,X,Y</code>.</p>
<p>The .csv containing 3D GCPs must have the format: <code>id,X,Y,Z</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Feature_finder:
    &#34;&#34;&#34;Find position of point features in simulated line scan image.

    The .csv containing 2D GCPs must have the format: `id,X,Y`.

    The .csv containing 3D GCPs must have the format: `id,X,Y,Z`.&#34;&#34;&#34;

    def __init__(self):
        self.names_2D = np.array([], dtype=object)
        self.points_2D = np.array([], dtype=object)
        self.coords_2D = np.empty((0, 2), dtype=float)

        self.names_3D = np.array([], dtype=object)
        self.points_3D = np.array([], dtype=object)
        self.coords_3D = np.empty((0, 3), dtype=float)

        self.Z_terrain = 0
        self.buffer = 0
        return

    def from_config(config):
        &#34;&#34;&#34;
        Initialize Feature_finder with config parameters.

        Parameters
        ----------
        config : Config
            Config instance containing desired parameters.

        Returns
        -------
        finder : Feature_finder
            initizialized Feature_finder instance.

        &#34;&#34;&#34;
        if not config[&#39;FIND_FEATURES&#39;]:
            return None

        finder = Feature_finder()
        finder.Z_terrain = config[&#39;MEAN_TERRAIN_HEIGHT&#39;]

        if config[&#39;FEATURE_CSV_PATH_2D&#39;]:
            filepath = config[&#39;FEATURE_CSV_PATH_2D&#39;]

            name_list = []
            coord_list = []
            point_list = []
            with open(filepath) as file:
                csv_reader = csv.reader(file)
                for row in csv_reader:
                    name_list.append(str(row[0]))
                    coords = (float(row[1]), float(row[2]))
                    point_list.append(Point(coords))
                    coord_list.append(coords)

            coord_list, point_list, name_list = zip(*sorted(zip(coord_list, point_list, name_list)))

            finder.coords_2D = np.array(coord_list)
            finder.names_2D = np.empty(len(name_list), dtype=object)
            finder.points_2D = np.empty(len(point_list), dtype=type(Point))
            for idx, (point, name) in enumerate(zip(point_list, name_list)):
                finder.points_2D[idx] = point
                finder.names_2D[idx] = name

        if config[&#39;FEATURE_CSV_PATH_3D&#39;]:
            filepath = config[&#39;FEATURE_CSV_PATH_3D&#39;]

            # read in 3D GCPs
            name_list = []
            coord_list = []
            point_list = []
            with open(filepath) as file:
                csv_reader = csv.reader(file)
                for row in csv_reader:
                    name_list.append(str(row[0]))
                    coords = (float(row[1]), float(row[2]), float(row[3]))
                    point_list.append(Point(coords))
                    coord_list.append(coords)

            coord_list, point_list, name_list = zip(*sorted(zip(coord_list, point_list, name_list)))

            finder.coords_3D = np.array(coord_list)     # fill array of point coordinates
            finder.names_3D = np.empty(len(name_list), dtype=object)
            finder.points_3D = np.empty(len(point_list), dtype=type(Point))
            for idx, (point, name) in enumerate(zip(point_list, name_list)):
                finder.points_3D[idx] = point           # fill array of Point objects
                finder.names_3D[idx] = name             # fill array of point names/identifiers as str

            approx_view_angle = np.deg2rad(config[&#39;APPROX_VIEW_ANGLE&#39;])
            max_roll = np.deg2rad(config[&#39;MAX_ROLL_ANGLE&#39;])

            # buffer to determine radius within which distorted 3D points may be found
            finder.buffer = np.max(np.abs(finder.coords_3D[:, 2] - finder.Z_terrain)) * np.tan(0.5 * approx_view_angle + max_roll)
        return finder

    def check(self, poly, vertices, line_idx, px_idx, sensor_name, pose):
        &#34;&#34;&#34;
        Check which of the Feature_finder&#39;s GCPs (if any) are contained within a polygon.

        Parameters
        ----------
        poly : Polygon
            Polygon to be checked.
        line_idx : int
            current pose.idx.
        px_idx : int
            current pixel&#39;s c coordinate.
        sensor_name : str
            current sensor&#39;s name.
        pose : Cam_pose
            current sensor&#39;s exterior orientation.

        Returns
        -------
        found_feats : list[tuple]
            list containing tuples with (GCP_name, line_idx, px_idx, sensor_name, GCP_X, GCP_Y, GCP_Z) of all GCPs contained in poly.
            GCPs without Z information are marked with GCP_Z = 999999.

        &#34;&#34;&#34;
        X_min, Y_min, X_max, Y_max = poly.bounds

        candidate_idxs = self._get_candidates_2D(X_min, Y_min, X_max, Y_max)
        # create list with tuple of format: (feature_name, row, column, sensor_name, feature_X, feature_Y, 999999)
        found_feats_2D = [(point_name, line_idx, px_idx, sensor_name, point_coords[0], point_coords[1], 999999) for point_name, point_coords, point in zip(self.names_2D[candidate_idxs], self.coords_2D[candidate_idxs], self.points_2D[candidate_idxs]) if poly.contains(point)]

        candidate_idxs = self._get_candidates_3D(X_min, Y_min, X_max, Y_max)
        # create list with tuple of format: (feature_name, row, column, sensor_name, feature_X, feature_Y, feature_Z)
        found_feats_3D = [(point_name, line_idx, px_idx, sensor_name, point_coords[0], point_coords[1], point_coords[2]) for point_name, point_coords, point in zip(self.names_3D[candidate_idxs], self.coords_3D[candidate_idxs], self.points_3D[candidate_idxs]) if self._get_poly_Z(vertices, point_coords[2], pose).contains(point)]

        return found_feats_2D + found_feats_3D

    def _get_candidates_3D(self, X_min, Y_min, X_max, Y_max):
        &#34;&#34;&#34;Preselect GCPs based on rectangular bounding box and buffer zone.&#34;&#34;&#34;
        start_idx = np.searchsorted(self.coords_3D[:, 0], X_min - self.buffer)
        stop_idx = start_idx + np.searchsorted(self.coords_3D[start_idx:, 0], X_max + self.buffer, &#39;right&#39;)

        candidate_idxs = start_idx + np.where(np.logical_and(self.coords_3D[start_idx:stop_idx, 1] &gt;= Y_min - self.buffer, self.coords_3D[start_idx:stop_idx, 1] &lt;= Y_max + self.buffer))[0]

        return candidate_idxs

    def _get_candidates_2D(self, X_min, Y_min, X_max, Y_max):
        &#34;&#34;&#34;Preselect GCPs based on rectangular bounding box.&#34;&#34;&#34;
        start_idx = np.searchsorted(self.coords_2D[:, 0], X_min)
        stop_idx = start_idx + np.searchsorted(self.coords_2D[start_idx:, 0], X_max, &#39;right&#39;)

        candidate_idxs = start_idx + np.where(np.logical_and(self.coords_2D[start_idx:stop_idx, 1] &gt;= Y_min, self.coords_2D[start_idx:stop_idx, 1] &lt;= Y_max))[0]

        return candidate_idxs

    def _get_ray_at_Z(self, point, proj_center, Z):
        &#34;&#34;&#34;Ray tracing for 3D GCP detection. Returns X, Y position of ray passing through point and proj_center at elevation Z.&#34;&#34;&#34;
        deltaZ = proj_center[2] - self.Z_terrain
        deltas = (proj_center[0:2] - point) / deltaZ
        X, Y = point + deltas * (Z - self.Z_terrain)
        return X, Y

    def _get_poly_Z(self, vertices, Z, pose):
        &#34;&#34;&#34;Create new Polygon at a candidate GCP&#39;s Z elevation to determine whether it is inside FOV.&#34;&#34;&#34;
        new_center = pose.XYZ_0
        old_center = pose.previous.XYZ_0
        poly_Z = Polygon([self._get_ray_at_Z(vertices[0], new_center, Z),
                          self._get_ray_at_Z(vertices[1], old_center, Z),
                          self._get_ray_at_Z(vertices[2], old_center, Z),
                          self._get_ray_at_Z(vertices[3], new_center, Z)])
        return poly_Z</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="satcamsim.input_imgs.Feature_finder.check"><code class="name flex">
<span>def <span class="ident">check</span></span>(<span>self, poly, vertices, line_idx, px_idx, sensor_name, pose)</span>
</code></dt>
<dd>
<div class="desc"><p>Check which of the Feature_finder's GCPs (if any) are contained within a polygon.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>poly</code></strong> :&ensp;<code>Polygon</code></dt>
<dd>Polygon to be checked.</dd>
<dt><strong><code>line_idx</code></strong> :&ensp;<code>int</code></dt>
<dd>current pose.idx.</dd>
<dt><strong><code>px_idx</code></strong> :&ensp;<code>int</code></dt>
<dd>current pixel's c coordinate.</dd>
<dt><strong><code>sensor_name</code></strong> :&ensp;<code>str</code></dt>
<dd>current sensor's name.</dd>
<dt><strong><code>pose</code></strong> :&ensp;<code>Cam_pose</code></dt>
<dd>current sensor's exterior orientation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>found_feats</code></strong> :&ensp;<code>list[tuple]</code></dt>
<dd>list containing tuples with (GCP_name, line_idx, px_idx, sensor_name, GCP_X, GCP_Y, GCP_Z) of all GCPs contained in poly.
GCPs without Z information are marked with GCP_Z = 999999.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check(self, poly, vertices, line_idx, px_idx, sensor_name, pose):
    &#34;&#34;&#34;
    Check which of the Feature_finder&#39;s GCPs (if any) are contained within a polygon.

    Parameters
    ----------
    poly : Polygon
        Polygon to be checked.
    line_idx : int
        current pose.idx.
    px_idx : int
        current pixel&#39;s c coordinate.
    sensor_name : str
        current sensor&#39;s name.
    pose : Cam_pose
        current sensor&#39;s exterior orientation.

    Returns
    -------
    found_feats : list[tuple]
        list containing tuples with (GCP_name, line_idx, px_idx, sensor_name, GCP_X, GCP_Y, GCP_Z) of all GCPs contained in poly.
        GCPs without Z information are marked with GCP_Z = 999999.

    &#34;&#34;&#34;
    X_min, Y_min, X_max, Y_max = poly.bounds

    candidate_idxs = self._get_candidates_2D(X_min, Y_min, X_max, Y_max)
    # create list with tuple of format: (feature_name, row, column, sensor_name, feature_X, feature_Y, 999999)
    found_feats_2D = [(point_name, line_idx, px_idx, sensor_name, point_coords[0], point_coords[1], 999999) for point_name, point_coords, point in zip(self.names_2D[candidate_idxs], self.coords_2D[candidate_idxs], self.points_2D[candidate_idxs]) if poly.contains(point)]

    candidate_idxs = self._get_candidates_3D(X_min, Y_min, X_max, Y_max)
    # create list with tuple of format: (feature_name, row, column, sensor_name, feature_X, feature_Y, feature_Z)
    found_feats_3D = [(point_name, line_idx, px_idx, sensor_name, point_coords[0], point_coords[1], point_coords[2]) for point_name, point_coords, point in zip(self.names_3D[candidate_idxs], self.coords_3D[candidate_idxs], self.points_3D[candidate_idxs]) if self._get_poly_Z(vertices, point_coords[2], pose).contains(point)]

    return found_feats_2D + found_feats_3D</code></pre>
</details>
</dd>
<dt id="satcamsim.input_imgs.Feature_finder.from_config"><code class="name flex">
<span>def <span class="ident">from_config</span></span>(<span>config)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize Feature_finder with config parameters.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>Config</code></dt>
<dd>Config instance containing desired parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>finder</code></strong> :&ensp;<code><a title="satcamsim.input_imgs.Feature_finder" href="#satcamsim.input_imgs.Feature_finder">Feature_finder</a></code></dt>
<dd>initizialized Feature_finder instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_config(config):
    &#34;&#34;&#34;
    Initialize Feature_finder with config parameters.

    Parameters
    ----------
    config : Config
        Config instance containing desired parameters.

    Returns
    -------
    finder : Feature_finder
        initizialized Feature_finder instance.

    &#34;&#34;&#34;
    if not config[&#39;FIND_FEATURES&#39;]:
        return None

    finder = Feature_finder()
    finder.Z_terrain = config[&#39;MEAN_TERRAIN_HEIGHT&#39;]

    if config[&#39;FEATURE_CSV_PATH_2D&#39;]:
        filepath = config[&#39;FEATURE_CSV_PATH_2D&#39;]

        name_list = []
        coord_list = []
        point_list = []
        with open(filepath) as file:
            csv_reader = csv.reader(file)
            for row in csv_reader:
                name_list.append(str(row[0]))
                coords = (float(row[1]), float(row[2]))
                point_list.append(Point(coords))
                coord_list.append(coords)

        coord_list, point_list, name_list = zip(*sorted(zip(coord_list, point_list, name_list)))

        finder.coords_2D = np.array(coord_list)
        finder.names_2D = np.empty(len(name_list), dtype=object)
        finder.points_2D = np.empty(len(point_list), dtype=type(Point))
        for idx, (point, name) in enumerate(zip(point_list, name_list)):
            finder.points_2D[idx] = point
            finder.names_2D[idx] = name

    if config[&#39;FEATURE_CSV_PATH_3D&#39;]:
        filepath = config[&#39;FEATURE_CSV_PATH_3D&#39;]

        # read in 3D GCPs
        name_list = []
        coord_list = []
        point_list = []
        with open(filepath) as file:
            csv_reader = csv.reader(file)
            for row in csv_reader:
                name_list.append(str(row[0]))
                coords = (float(row[1]), float(row[2]), float(row[3]))
                point_list.append(Point(coords))
                coord_list.append(coords)

        coord_list, point_list, name_list = zip(*sorted(zip(coord_list, point_list, name_list)))

        finder.coords_3D = np.array(coord_list)     # fill array of point coordinates
        finder.names_3D = np.empty(len(name_list), dtype=object)
        finder.points_3D = np.empty(len(point_list), dtype=type(Point))
        for idx, (point, name) in enumerate(zip(point_list, name_list)):
            finder.points_3D[idx] = point           # fill array of Point objects
            finder.names_3D[idx] = name             # fill array of point names/identifiers as str

        approx_view_angle = np.deg2rad(config[&#39;APPROX_VIEW_ANGLE&#39;])
        max_roll = np.deg2rad(config[&#39;MAX_ROLL_ANGLE&#39;])

        # buffer to determine radius within which distorted 3D points may be found
        finder.buffer = np.max(np.abs(finder.coords_3D[:, 2] - finder.Z_terrain)) * np.tan(0.5 * approx_view_angle + max_roll)
    return finder</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="satcamsim.input_imgs.Input_processor"><code class="flex name class">
<span>class <span class="ident">Input_processor</span></span>
</code></dt>
<dd>
<div class="desc"><p>Facilitate and simplify operations involving the input images.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>bands</code></strong> :&ensp;<code>tuple</code> of <code>int</code></dt>
<dd>the band indices to be read from the input data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>Input_processor</code></strong> :&ensp;<code><a title="satcamsim.input_imgs.Input_processor" href="#satcamsim.input_imgs.Input_processor">Input_processor</a></code></dt>
<dd>a new Input_processor instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Input_processor:
    &#34;&#34;&#34;
    Facilitate and simplify operations involving the input images.

    Parameters
    ----------
    bands : tuple of int
        the band indices to be read from the input data.

    Returns
    -------
    Input_processor : Input_processor
        a new Input_processor instance.

    &#34;&#34;&#34;

    def __init__(self):
        self.open_files = dict()
        self.available_files = np.array([], dtype=object)
        self.bounds = np.empty((0, 4), dtype=float)
        return

    def from_config(config):
        &#34;&#34;&#34;
        Initialize a new Input_processor with the parameters specified in config.

        Parameters
        ----------
        config : Config
            Config containing all relevant parameters.

        Returns
        -------
        processor : Input_processor
            The initialized Input_processor instance.

        &#34;&#34;&#34;
        processor = Input_processor()
        processor.max_open_files = config[&#39;MAX_OPEN_FILES&#39;]
        processor.folder_in = config[&#39;FOLDER_IN&#39;]
        processor.file_extension = config[&#39;FILEEXTENSION_IN&#39;]
        processor.nodata = config[&#39;NODATA_IN&#39;]
        return processor

    def __del__(self):
        &#34;&#34;&#34;
        Guarantee that all files are closed before deletion.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        for _, file in self.open_files.items():
            file.close()
        return

    def __enter__(self):
        &#34;&#34;&#34;
        Return self for use in context manager.

        Returns
        -------
        self : Input_processor
            The Input_processor instance for the context manager.

        &#34;&#34;&#34;
        self.available_files = np.array(glob(self.folder_in + &#39;*&#39; + self.file_extension))
        
        self.bounds = np.full((len(self.available_files), 4), np.nan, dtype=float)
        for idx, file in enumerate(self.available_files):
            with rasterio.open(file) as f:
                self.bounds[idx, :] = f.bounds
                
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        &#34;&#34;&#34;
        Ensure proper closing of all files when exiting context manager.

        Parameters
        ----------
        exc_type : exception type or None
            Type of exception raised within context manager, or None.
        exc_value : Exception or None
            The exception raised within context manager, or None.
        traceback : Traceback or None
            Traceback object for the raised exception, or None.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        for _, file in self.open_files.items():
            file.close()
        return

    def sample_area(self, corners_obj, bands):
        &#34;&#34;&#34;
        Compute mean of raster data within the polygonal area specified by its corners in object coordinates.

        Parameters
        ----------
        corners_obj: list of tuple
            list of (X, Y) coordinate tuples representing polygon corners.
        bands : tuple of int
            tuple of the band indices to be read.

        Returns
        -------
        flag : bool
            True if sampling was successful for all requested bands, False otherwise.
        sample : np.array or None
            array of shape (n_bands,) containing mean values for each band if sampling was successful, None otherwise.
        poly : shapely.geometry.Polygon
            the polygon area that was sampled (=ground track coverage). Returned even if sampling was unsuccessful.

        &#34;&#34;&#34;
        # create polygon of area of pixel projected onto terrain
        poly = Polygon(corners_obj)

        is_success, data_list, trans_list = self.read_data(poly, corners_obj, bands)

        if not is_success:
            return False, None, poly
        
        sum_samples = np.zeros((len(bands),), dtype=float)
        num_samples = 0.
        for data, data_trans in zip(data_list, trans_list):
            # determine contained input pixels in read-in data
            contained = features.rasterize([(poly, 1)], out_shape=data.shape[1:], fill=0, transform=data_trans)
            
            # check nodata
            data = data[:, contained.astype(bool)]
            if self.nodata in data:
                return False, None, poly
    
            sum_samples += data.sum(axis=1)        # sum sampled pixel values per band
            num_samples += contained.sum()         # no. of sampled pixels

        sample = sum_samples / num_samples        # compute mean sampled pixel values

        return True, sample, poly

    def get_filenames(self, objcoords):
        &#34;&#34;&#34;
        Construct all file names containing specified points.

        Parameters
        ----------
        objcoords : list[tuple]
            list of point coordinate tuples in (X, Y) format.

        Returns
        -------
        filenames : list[str]
            contains unique names of the files, ordered by ascending X, if equal by ascending Y positions.

        &#34;&#34;&#34;
        if not hasattr(objcoords[0], &#34;__len__&#34;):    # if a single point is specified instead of list of points
            return self.get_filenames([objcoords])

        filenames = list()
        
        objcoords = sorted(objcoords)
        for X, Y in objcoords:
            fname = self.available_files[(self.bounds[:, 0] &lt;= X) &amp;  (self.bounds[:, 1] &lt;= Y) &amp; (X &lt;= self.bounds[:, 2]) &amp; (Y &lt;= self.bounds[:, 3])]
            if len(fname) != 1:
                # if file could not be uniquely identified
                return False, None
            
            filenames.append(fname[0])
            
        filenames = list(dict.fromkeys(filenames))  # keep only unique filenames while preserving order
        return True, filenames

    def _open_file(self, filename):
        &#34;&#34;&#34;
        Open specified files from disk.

        Parameters
        ----------
        filename : str
            name of file to be loaded.

        Returns
        -------
        flag : bool
            True if file was successfully opened, False otherwise.

        &#34;&#34;&#34;
        if filename not in self.open_files:
            if len(self.open_files) &gt;= self.max_open_files:
                self._close_files(len(self.open_files) - self.max_open_files)

            self.open_files[filename] = rasterio.open(filename)
        return

    def read_data(self, poly, vertices, bands):
        &#34;&#34;&#34;
        Read a rectangular bounding box containing the specified Polygon from input files.
        The current implementation may break if input files use a CRS/transform where not X==East==right, Y==North==up.

        Parameters
        ----------
        poly : shapely.geometry.Polygon
            Polygonal ROI which will be fully covered by the read-in data.
        vertices : np.ndarray
            coordinates of ROI vertices.
        bands : tuple of int
             tuple of the band indices to be read.

        Returns
        -------
        flag : bool
            True if data was read in successfully, False otherwise.
        data : np.ndarray or None
            raster data contained in the rectangular bounding box around poly, if successful. None otherwise.
        data_trans : rasterio.affine.Affine or None
            Affine transform from raster data pixels to object coordinates, if successful. None otherwise.

        &#34;&#34;&#34;
        polybounds = poly.bounds
        
        # determine required input files from bounding box corners and try to load them if necessary
        all_files_found, filenames = self.get_filenames([polybounds[0:2],       # SW corner    (yes
                                                         polybounds[0::3],      # NW corner     this
                                                         polybounds[2:0:-1],    # SE corner     is
                                                         polybounds[2:]])       # NE corner     ugly)
        
        if not all_files_found:
            # if coordinates could not be assigned to a unique input file
            return False, None, None
        
        for filename in filenames:
            if filename not in self.open_files:
                self._open_file(filename)
        
        if len(filenames) == 1:
            file = self.open_files[filenames[0]]
            # windowed reading from input file
            poly_window = windows.from_bounds(*polybounds, transform=file.transform)
            data_trans = windows.transform(poly_window, file.transform)
            data = file.read(bands, window=poly_window)
            
            if 0 in data.shape:
                # can happen if only a very thin (&lt; 0.5 input pixels) part of the poly intersects with the input images
                return False, None, None
            return True, [data], [data_trans]

        data_list = []
        trans_list = []
        for filename in filenames:
            file = self.open_files[filename]
            
            # trim bounding box to not extend beyond limits of the file
            # (this will absolutely break if file uses a weird CRS/transform where not X==East==right, Y==North==up:
            # rasterio orders file.bounds as &#39;left, bottom, right, top&#39;, which is not necessarily the same as &#39;X_min, Y_min, X_max, Y_max&#39;.
            # thats&#39;s what geodesysts get for inventing stupid coordinate systems with insane axis ordering, and frankly I won&#39;t clean their mess for them)
            windowbounds = [max(polymin, filemin) for polymin, filemin in zip(polybounds[:2], file.bounds[:2])] + [min(polymax, filemax) for polymax, filemax in zip(polybounds[2:], file.bounds[2:])]

            # windowed reading from input file
            poly_window = windows.from_bounds(*windowbounds, transform=file.transform)
            data_trans = windows.transform(poly_window, file.transform)
            data = file.read(bands, window=poly_window)

            if 0 in data.shape:
                # can happen if only a very thin (&lt; 0.5 input pixels) part of the poly intersects with the input images
                continue
            
            data_list.append(data)
            trans_list.append(data_trans)

        return True, data_list, trans_list

    def _close_files(self, n_files=-1):
        &#34;&#34;&#34;
        Close files that have been open the longest (oldest file in dict).

        Parameters
        ----------
        n_files : int, optional
            Number of files to close, or -1 to close all files. The default is -1.
            Note: if n_files &gt;= len(self.open_files), all files will be closed.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        if n_files == -1 or n_files &gt; len(self.open_files):
            n_files = len(self.open_files)

        for _ in range(n_files):
            filename, file = next(iter(self.open_files.items()))
            file.close()
            del self.open_files[filename]
        return</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="satcamsim.input_imgs.Input_processor.from_config"><code class="name flex">
<span>def <span class="ident">from_config</span></span>(<span>config)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize a new Input_processor with the parameters specified in config.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>Config</code></dt>
<dd>Config containing all relevant parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>processor</code></strong> :&ensp;<code><a title="satcamsim.input_imgs.Input_processor" href="#satcamsim.input_imgs.Input_processor">Input_processor</a></code></dt>
<dd>The initialized Input_processor instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_config(config):
    &#34;&#34;&#34;
    Initialize a new Input_processor with the parameters specified in config.

    Parameters
    ----------
    config : Config
        Config containing all relevant parameters.

    Returns
    -------
    processor : Input_processor
        The initialized Input_processor instance.

    &#34;&#34;&#34;
    processor = Input_processor()
    processor.max_open_files = config[&#39;MAX_OPEN_FILES&#39;]
    processor.folder_in = config[&#39;FOLDER_IN&#39;]
    processor.file_extension = config[&#39;FILEEXTENSION_IN&#39;]
    processor.nodata = config[&#39;NODATA_IN&#39;]
    return processor</code></pre>
</details>
</dd>
<dt id="satcamsim.input_imgs.Input_processor.get_filenames"><code class="name flex">
<span>def <span class="ident">get_filenames</span></span>(<span>self, objcoords)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct all file names containing specified points.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>objcoords</code></strong> :&ensp;<code>list[tuple]</code></dt>
<dd>list of point coordinate tuples in (X, Y) format.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>filenames</code></strong> :&ensp;<code>list[str]</code></dt>
<dd>contains unique names of the files, ordered by ascending X, if equal by ascending Y positions.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_filenames(self, objcoords):
    &#34;&#34;&#34;
    Construct all file names containing specified points.

    Parameters
    ----------
    objcoords : list[tuple]
        list of point coordinate tuples in (X, Y) format.

    Returns
    -------
    filenames : list[str]
        contains unique names of the files, ordered by ascending X, if equal by ascending Y positions.

    &#34;&#34;&#34;
    if not hasattr(objcoords[0], &#34;__len__&#34;):    # if a single point is specified instead of list of points
        return self.get_filenames([objcoords])

    filenames = list()
    
    objcoords = sorted(objcoords)
    for X, Y in objcoords:
        fname = self.available_files[(self.bounds[:, 0] &lt;= X) &amp;  (self.bounds[:, 1] &lt;= Y) &amp; (X &lt;= self.bounds[:, 2]) &amp; (Y &lt;= self.bounds[:, 3])]
        if len(fname) != 1:
            # if file could not be uniquely identified
            return False, None
        
        filenames.append(fname[0])
        
    filenames = list(dict.fromkeys(filenames))  # keep only unique filenames while preserving order
    return True, filenames</code></pre>
</details>
</dd>
<dt id="satcamsim.input_imgs.Input_processor.read_data"><code class="name flex">
<span>def <span class="ident">read_data</span></span>(<span>self, poly, vertices, bands)</span>
</code></dt>
<dd>
<div class="desc"><p>Read a rectangular bounding box containing the specified Polygon from input files.
The current implementation may break if input files use a CRS/transform where not X==East==right, Y==North==up.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>poly</code></strong> :&ensp;<code>shapely.geometry.Polygon</code></dt>
<dd>Polygonal ROI which will be fully covered by the read-in data.</dd>
<dt><strong><code>vertices</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>coordinates of ROI vertices.</dd>
<dt><strong><code>bands</code></strong> :&ensp;<code>tuple</code> of <code>int</code></dt>
<dd>tuple of the band indices to be read.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>flag</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if data was read in successfully, False otherwise.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>np.ndarray</code> or <code>None</code></dt>
<dd>raster data contained in the rectangular bounding box around poly, if successful. None otherwise.</dd>
<dt><strong><code>data_trans</code></strong> :&ensp;<code>rasterio.affine.Affine</code> or <code>None</code></dt>
<dd>Affine transform from raster data pixels to object coordinates, if successful. None otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_data(self, poly, vertices, bands):
    &#34;&#34;&#34;
    Read a rectangular bounding box containing the specified Polygon from input files.
    The current implementation may break if input files use a CRS/transform where not X==East==right, Y==North==up.

    Parameters
    ----------
    poly : shapely.geometry.Polygon
        Polygonal ROI which will be fully covered by the read-in data.
    vertices : np.ndarray
        coordinates of ROI vertices.
    bands : tuple of int
         tuple of the band indices to be read.

    Returns
    -------
    flag : bool
        True if data was read in successfully, False otherwise.
    data : np.ndarray or None
        raster data contained in the rectangular bounding box around poly, if successful. None otherwise.
    data_trans : rasterio.affine.Affine or None
        Affine transform from raster data pixels to object coordinates, if successful. None otherwise.

    &#34;&#34;&#34;
    polybounds = poly.bounds
    
    # determine required input files from bounding box corners and try to load them if necessary
    all_files_found, filenames = self.get_filenames([polybounds[0:2],       # SW corner    (yes
                                                     polybounds[0::3],      # NW corner     this
                                                     polybounds[2:0:-1],    # SE corner     is
                                                     polybounds[2:]])       # NE corner     ugly)
    
    if not all_files_found:
        # if coordinates could not be assigned to a unique input file
        return False, None, None
    
    for filename in filenames:
        if filename not in self.open_files:
            self._open_file(filename)
    
    if len(filenames) == 1:
        file = self.open_files[filenames[0]]
        # windowed reading from input file
        poly_window = windows.from_bounds(*polybounds, transform=file.transform)
        data_trans = windows.transform(poly_window, file.transform)
        data = file.read(bands, window=poly_window)
        
        if 0 in data.shape:
            # can happen if only a very thin (&lt; 0.5 input pixels) part of the poly intersects with the input images
            return False, None, None
        return True, [data], [data_trans]

    data_list = []
    trans_list = []
    for filename in filenames:
        file = self.open_files[filename]
        
        # trim bounding box to not extend beyond limits of the file
        # (this will absolutely break if file uses a weird CRS/transform where not X==East==right, Y==North==up:
        # rasterio orders file.bounds as &#39;left, bottom, right, top&#39;, which is not necessarily the same as &#39;X_min, Y_min, X_max, Y_max&#39;.
        # thats&#39;s what geodesysts get for inventing stupid coordinate systems with insane axis ordering, and frankly I won&#39;t clean their mess for them)
        windowbounds = [max(polymin, filemin) for polymin, filemin in zip(polybounds[:2], file.bounds[:2])] + [min(polymax, filemax) for polymax, filemax in zip(polybounds[2:], file.bounds[2:])]

        # windowed reading from input file
        poly_window = windows.from_bounds(*windowbounds, transform=file.transform)
        data_trans = windows.transform(poly_window, file.transform)
        data = file.read(bands, window=poly_window)

        if 0 in data.shape:
            # can happen if only a very thin (&lt; 0.5 input pixels) part of the poly intersects with the input images
            continue
        
        data_list.append(data)
        trans_list.append(data_trans)

    return True, data_list, trans_list</code></pre>
</details>
</dd>
<dt id="satcamsim.input_imgs.Input_processor.sample_area"><code class="name flex">
<span>def <span class="ident">sample_area</span></span>(<span>self, corners_obj, bands)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute mean of raster data within the polygonal area specified by its corners in object coordinates.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>corners_obj</code></strong> :&ensp;<code>list</code> of <code>tuple</code></dt>
<dd>list of (X, Y) coordinate tuples representing polygon corners.</dd>
<dt><strong><code>bands</code></strong> :&ensp;<code>tuple</code> of <code>int</code></dt>
<dd>tuple of the band indices to be read.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>flag</code></strong> :&ensp;<code>bool</code></dt>
<dd>True if sampling was successful for all requested bands, False otherwise.</dd>
<dt><strong><code>sample</code></strong> :&ensp;<code>np.array</code> or <code>None</code></dt>
<dd>array of shape (n_bands,) containing mean values for each band if sampling was successful, None otherwise.</dd>
<dt><strong><code>poly</code></strong> :&ensp;<code>shapely.geometry.Polygon</code></dt>
<dd>the polygon area that was sampled (=ground track coverage). Returned even if sampling was unsuccessful.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_area(self, corners_obj, bands):
    &#34;&#34;&#34;
    Compute mean of raster data within the polygonal area specified by its corners in object coordinates.

    Parameters
    ----------
    corners_obj: list of tuple
        list of (X, Y) coordinate tuples representing polygon corners.
    bands : tuple of int
        tuple of the band indices to be read.

    Returns
    -------
    flag : bool
        True if sampling was successful for all requested bands, False otherwise.
    sample : np.array or None
        array of shape (n_bands,) containing mean values for each band if sampling was successful, None otherwise.
    poly : shapely.geometry.Polygon
        the polygon area that was sampled (=ground track coverage). Returned even if sampling was unsuccessful.

    &#34;&#34;&#34;
    # create polygon of area of pixel projected onto terrain
    poly = Polygon(corners_obj)

    is_success, data_list, trans_list = self.read_data(poly, corners_obj, bands)

    if not is_success:
        return False, None, poly
    
    sum_samples = np.zeros((len(bands),), dtype=float)
    num_samples = 0.
    for data, data_trans in zip(data_list, trans_list):
        # determine contained input pixels in read-in data
        contained = features.rasterize([(poly, 1)], out_shape=data.shape[1:], fill=0, transform=data_trans)
        
        # check nodata
        data = data[:, contained.astype(bool)]
        if self.nodata in data:
            return False, None, poly

        sum_samples += data.sum(axis=1)        # sum sampled pixel values per band
        num_samples += contained.sum()         # no. of sampled pixels

    sample = sum_samples / num_samples        # compute mean sampled pixel values

    return True, sample, poly</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="satcamsim" href="index.html">satcamsim</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="satcamsim.input_imgs.Comp_processor" href="#satcamsim.input_imgs.Comp_processor">Comp_processor</a></code></h4>
<ul class="">
<li><code><a title="satcamsim.input_imgs.Comp_processor.cut_geom" href="#satcamsim.input_imgs.Comp_processor.cut_geom">cut_geom</a></code></li>
<li><code><a title="satcamsim.input_imgs.Comp_processor.from_config" href="#satcamsim.input_imgs.Comp_processor.from_config">from_config</a></code></li>
<li><code><a title="satcamsim.input_imgs.Comp_processor.glue_geoms" href="#satcamsim.input_imgs.Comp_processor.glue_geoms">glue_geoms</a></code></li>
<li><code><a title="satcamsim.input_imgs.Comp_processor.read_from_file" href="#satcamsim.input_imgs.Comp_processor.read_from_file">read_from_file</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="satcamsim.input_imgs.Feature_finder" href="#satcamsim.input_imgs.Feature_finder">Feature_finder</a></code></h4>
<ul class="">
<li><code><a title="satcamsim.input_imgs.Feature_finder.check" href="#satcamsim.input_imgs.Feature_finder.check">check</a></code></li>
<li><code><a title="satcamsim.input_imgs.Feature_finder.from_config" href="#satcamsim.input_imgs.Feature_finder.from_config">from_config</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="satcamsim.input_imgs.Input_processor" href="#satcamsim.input_imgs.Input_processor">Input_processor</a></code></h4>
<ul class="">
<li><code><a title="satcamsim.input_imgs.Input_processor.from_config" href="#satcamsim.input_imgs.Input_processor.from_config">from_config</a></code></li>
<li><code><a title="satcamsim.input_imgs.Input_processor.get_filenames" href="#satcamsim.input_imgs.Input_processor.get_filenames">get_filenames</a></code></li>
<li><code><a title="satcamsim.input_imgs.Input_processor.read_data" href="#satcamsim.input_imgs.Input_processor.read_data">read_data</a></code></li>
<li><code><a title="satcamsim.input_imgs.Input_processor.sample_area" href="#satcamsim.input_imgs.Input_processor.sample_area">sample_area</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>